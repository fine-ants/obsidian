
## VM 인스턴스 생성
Compute Engine 서비스로 이동 후 인스턴스를 만듭니다.
![](BE/메뉴얼/GCP/refImg/Pasted%20image%2020250829134751.png)

인스턴스 생성 정보 입력
![](BE/메뉴얼/GCP/refImg/Pasted%20image%2020250829134652.png)

![](BE/메뉴얼/GCP/refImg/Pasted%20image%2020250829135031.png)

부팅 디스크 이미지 변경
![](BE/메뉴얼/GCP/refImg/Pasted%20image%2020250829140226.png)

네트워킹 설정
![](BE/메뉴얼/GCP/refImg/Pasted%20image%2020250829140347.png)

![](BE/메뉴얼/GCP/refImg/Pasted%20image%2020250829140445.png)

![](BE/메뉴얼/GCP/refImg/Pasted%20image%2020250829140452.png)

인스턴스 생성 확인
![](BE/메뉴얼/GCP/refImg/Pasted%20image%2020250829140826.png)

VPC 네트워크 -> 방화벽 서비스로 이동
![](BE/메뉴얼/GCP/refImg/Pasted%20image%2020250829141836.png)

방화벽 규칙 만들기
![](BE/메뉴얼/GCP/refImg/Pasted%20image%2020250829141915.png)

방화벽 규칙 생성 정보 입력
![](BE/메뉴얼/GCP/refImg/Pasted%20image%2020250829142508.png)
![](BE/메뉴얼/GCP/refImg/Pasted%20image%2020250829142528.png)

방화벽 규칙 생성 확인
![](BE/메뉴얼/GCP/refImg/Pasted%20image%2020250829142558.png)

VM 인스턴스 SSH 접속 확인
![](BE/메뉴얼/GCP/refImg/Pasted%20image%2020250829142805.png)

실행 결과를 보면 정상적으로 VM 인스턴스에 SSH 연결된 것을 확인할 수 있습니다.
![](BE/메뉴얼/GCP/refImg/Pasted%20image%2020250829142838.png)

## SSH 키 생성 및 인스턴스 접속
- GCP 콘솔에서 인스턴스를 선택하고 브라우저를 통해서 접속하거나 Cloud Shell을 통해서 접속이 가능합니다. 그러나 해당 인스턴스에 접속하기 위해서는 GCP 콘솔을 통해서만 가능합니다.
- 제가 원하는 것은 로컬 터미널에서 SSH 키를 이용해서 원격 접속하는 것입니다.

### SSH 키 생성하기
ssh-keygen 명령어 형식
```shell
ssh-keygen -t rsa -f ~/.ssh/<KEY_FILENAME> -C <USERNAME>
```
- option `-t` : key 생성 타입을 선택하는 옵션
- option `-f` : 생성할 key 파일의 이름을 설정하는 옵션
- option `-C` : 사용자에 대한 주석을 입력하는 옵션
- `<KEY_FILENAME>` : 개인키 파일 이름
- `<USERNAME>` : GCP VM에서 사용할 사용자명
- 

SSH 키 생성
- 실행 결과를 보면 사용자의 .ssh 디렉토리에 공개키와 개인키가 생성됩니다.
```shell
ssh-keygen -t rsa -f ~/.ssh/gcp_vm -C fineants
```
![](BE/메뉴얼/GCP/refImg/Pasted%20image%2020250829145629.png)

### 생성된 SSH 키를 GCP 콘솔을 통해 서버에 등록하기
생성한 SSH key 쌍 중에서 `.pub` 확장자를 가진 public key를 GCP 콘솔을 통해 서버에 등록해야 합니다.

GCP 콘솔 -> 메타데이터 -> SSH 키 추가
![](BE/메뉴얼/GCP/refImg/Pasted%20image%2020250829150024.png)

SSH 키 값 추가
![](BE/메뉴얼/GCP/refImg/Pasted%20image%2020250829150205.png)

SSH 키 추가 확인
![](BE/메뉴얼/GCP/refImg/Pasted%20image%2020250829150302.png)

### 로컬 SSH 설정 파일에 접속 정보 추가
- 로컬 환경에서 `~/.ssh/config` 파일에 GCP 인스턴스에 SSH 접속하기 위해서 다음과 같이 정보를 추가함
```
Host fineants-gcp
HostName {instance 외부 IP 주소}
User fineants
Port 22
IdentityFile ~/.ssh/gcp_vm
```

SSH 연결 접속 확인
- 실행 결과를 보면 정상적으로 원격 접속하였습니다.
```shell
ssh fineants-gcp
```
![](BE/메뉴얼/GCP/refImg/Pasted%20image%2020250829150822.png)
- fineants@fineants-vm
	- fineants : 사용자이름
	- fineants-vm : 호스트이름


## 백엔드 서버 환경 구성
### 패키지 매니저 업데이트
```shell
sudo apt-get update -y
```
![](BE/메뉴얼/GCP/refImg/Pasted%20image%2020250829152004.png)


### 도커 프로세스 설치
도커 공식 GPG key 추가
```bash
# Add Docker's official GPG key:
sudo apt-get update
sudo apt-get install ca-certificates curl
sudo install -m 0755 -d /etc/apt/keyrings
sudo curl -fsSL https://download.docker.com/linux/ubuntu/gpg -o /etc/apt/keyrings/docker.asc
sudo chmod a+r /etc/apt/keyrings/docker.asc
```

Apt 소스들에 저장소 추가하기
- Docker APT 저장소를 시스템에 등록하는 단계
- 등록하면 `apt-get install docker-ce` 같은 명령으로 공식 Docker 패키지 설치 가능
```bash
# Add the repository to Apt sources:
echo \
  "deb [arch=$(dpkg --print-architecture) signed-by=/etc/apt/keyrings/docker.asc] https://download.docker.com/linux/ubuntu \
  $(. /etc/os-release && echo "${UBUNTU_CODENAME:-$VERSION_CODENAME}") stable" | \
  sudo tee /etc/apt/sources.list.d/docker.list > /dev/null
sudo apt-get update
```

도커 패키지 설치
```shell
sudo apt-get install docker-ce docker-ce-cli containerd.io docker-buildx-plugin docker-compose-plugin
```

도커 설치 확인
```shell
sudo docker run hello-world
```
![](BE/메뉴얼/GCP/refImg/Pasted%20image%2020250829153513.png)

현재 사용자를 docker 그룹에 추가
```shell
sudo usermod -aG docker $USER
```

docker 명령어 실행확인
- docker 명령어 실행확인하기 전에 SSH 재접속하시오.
- 다음 실행 결과를 보면 이제 별도의 `sudo` 명령어 접두사없이 docker 명령어를 사용할 수 있습니다.
```shell
docker ps
```
![](BE/메뉴얼/GCP/refImg/Pasted%20image%2020250829153811.png)


### docker-compose 설치
```shell
sudo apt-get update
sudo apt-get install docker-compose-plugin
sudo curl -L https://github.com/docker/compose/releases/latest/download/docker-compose-$(uname -s)-$(uname -m) -o /usr/local/bin/docker-compose
sudo chmod +x /usr/local/bin/docker-compose
sudo ln -s /usr/local/bin/docker-compose /usr/bin/docker-compose
docker-compose --version
```
![](BE/메뉴얼/GCP/refImg/Pasted%20image%2020250829154344.png)


## swap-memory 설정
현재 메모리 사용 상태 확인
```shell
free -h
```
![](BE/메뉴얼/GCP/refImg/Pasted%20image%2020250829162036.png)

Swap Memory 생성
```shell
sudo fallocate -l 2G ./swapfile
```

Swap Memory 파티션 지정
```shell
sudo mkswap ./swapfile
```

Swap Memory 활성화
```shell
sudo chmod 600 ./swapfile
sudo swapon ./swapfile
```

 /etc/fstab 파일에 Swap Memory 정보 추가
 - `/etc/fstab` 파일은 **리눅스가 부팅될 때 자동으로 마운트해야 할 파일시스템(디스크, 파티션, 스왑 등)의 목록**을 정의하는 설정 파일입니다.
- 리눅스 부팅시 마운트 정보를 가지고 있는 파일입니다. 이 파일에 추가해주어야 swap memory가 유효합니다.
- 파일 제일 아래쪽에 다음 내용을 추가합니다.
```shell
sudo vim /etc/fstab
```

/etc/fstab
```jsx
/home/fineants/swapfile swap swap defaults 0 0
```
- `/home/fineants/swapfile`  
    → 실제 스왑 파일의 경로
- `swap` (두 번째 항목)  
    → 장치 유형을 나타냅니다. 여기서는 "이 파일은 스왑 공간"임을 의미
- `swap` (세 번째 항목)  
    → 파일시스템 타입 (여기서도 "swap"이라고 명시)
- `defaults`  
    → 기본 마운트 옵션 사용
- `0` (다섯 번째 항목)  
    → 덤프(dump) 백업 여부 (스왑에는 필요 없음 → 0)
- `0` (여섯 번째 항목)  
    → fsck(파일시스템 체크) 여부 (스왑은 체크할 필요 없음 → 0)

Swap Memory 실행 결과 확인
```shell
free -h
```
![](BE/메뉴얼/GCP/refImg/Pasted%20image%2020250829162926.png)


docker build
```shell
docker build --platform linux/amd64 -f Dockerfile.production -t fineants/fineants-app:production-test .
```

docker push
```shell
docker push fineants/fineants-app:production-test
```

## MySQL 데이터 GCP Storage 버킷에 백업하기
배경
- GCP Compute Engine VM 위에서 Docker MySQL 컨테이너 실행 중
- 데이터 경로 : /home/ifneants/FineAnts-was/mysql/data
	- 호스트 볼륨에 MySQL 데이터 저장
- 목표: 하루에 한번 MySQL 데이터를 압축 후 GCP Storage 버킷에 업로드

#### 1. VM에 gcloud와 gsutil 설치 확인
```shell
gcloud version
```
![](BE/메뉴얼/GCP/refImg/Pasted%20image%2020250916111845.png)

```shell
gsutil version
```
![](BE/메뉴얼/GCP/refImg/Pasted%20image%2020250916111911.png)

#### 2. GCP 인증(서비스 계정 권장)
VM이 이미 서비스 계정으로 실행중이라면 추가 인증은 불필요합니다.
```shell
gcloud auth list
```
![](BE/메뉴얼/GCP/refImg/Pasted%20image%2020250916112054.png)
- 실행 결과를 보면 한개의 서비스 계정이 등록되어 있는 것을 볼수 있습니다.

#### 3. MySQL 데이터 디렉토리 압축 스크립트 작성
backup_mysql_data.sh
```shell
BACKUP_DIR="/home/fineants/FineAnts-was/mysql/data"  
BACKUP_FILE="/home/fineants/mysql-backup.tar.gz"  
  
tar -czf "$BACKUP_FILE" -C "$BACKUP_DIR" .
```

#### 4. GCP Storage 버킷에 업로드
```shell
gsutil cp "$BACKUP_FILE" gs://gcp-fineants-backup/mysql/
```



todo
- [x] docker-compose GCP에 맞게 수정
- [x] docker-compose 실행시 spring에 의해서 mysql 데이터베이스 데이터 초기화
- [x] gcp storage에 저장된 프로필 사진을 공개로 수정
- [x] WS와 관련된 소스 코드들을 GCP에 맞게 수정
	- 추상화(인터페이스)를 이용하여 AWS 소스코드들을 그대로 둔채 GCP 소스 코드로 확장
- [x] 인프라 관련 코드들에서 AWS 소스코드를 둔채 GCP로 확장
- [x] AWS 관련 소스 코드
	- 프로필 사진 저장 및 읽기, 삭제
	- 배당금 정보 작성 및 읽기
	- 종목 정보 작성 및 읽기
- compute engine의 mysql 볼륨 데이터를 주기적으로 백업하는 기능 구현

