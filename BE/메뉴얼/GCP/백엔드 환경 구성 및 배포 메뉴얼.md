
## VM 인스턴스 생성
Compute Engine 서비스로 이동 후 인스턴스를 만듭니다.
![](BE/메뉴얼/GCP/refImg/Pasted%20image%2020250829134751.png)

인스턴스 생성 정보 입력
![](BE/메뉴얼/GCP/refImg/Pasted%20image%2020250829134652.png)

![](BE/메뉴얼/GCP/refImg/Pasted%20image%2020250829135031.png)

부팅 디스크 이미지 변경
![](BE/메뉴얼/GCP/refImg/Pasted%20image%2020250829140226.png)

네트워킹 설정
![](BE/메뉴얼/GCP/refImg/Pasted%20image%2020250829140347.png)

![](BE/메뉴얼/GCP/refImg/Pasted%20image%2020250829140445.png)

![](BE/메뉴얼/GCP/refImg/Pasted%20image%2020250829140452.png)

인스턴스 생성 확인
![](BE/메뉴얼/GCP/refImg/Pasted%20image%2020250829140826.png)

VPC 네트워크 -> 방화벽 서비스로 이동
![](BE/메뉴얼/GCP/refImg/Pasted%20image%2020250829141836.png)

방화벽 규칙 만들기
![](BE/메뉴얼/GCP/refImg/Pasted%20image%2020250829141915.png)

방화벽 규칙 생성 정보 입력
![](BE/메뉴얼/GCP/refImg/Pasted%20image%2020250829142508.png)
![](BE/메뉴얼/GCP/refImg/Pasted%20image%2020250829142528.png)

방화벽 규칙 생성 확인
![](BE/메뉴얼/GCP/refImg/Pasted%20image%2020250829142558.png)

VM 인스턴스 SSH 접속 확인
![](BE/메뉴얼/GCP/refImg/Pasted%20image%2020250829142805.png)

실행 결과를 보면 정상적으로 VM 인스턴스에 SSH 연결된 것을 확인할 수 있습니다.
![](BE/메뉴얼/GCP/refImg/Pasted%20image%2020250829142838.png)

## SSH 키 생성 및 인스턴스 접속
- GCP 콘솔에서 인스턴스를 선택하고 브라우저를 통해서 접속하거나 Cloud Shell을 통해서 접속이 가능합니다. 그러나 해당 인스턴스에 접속하기 위해서는 GCP 콘솔을 통해서만 가능합니다.
- 제가 원하는 것은 로컬 터미널에서 SSH 키를 이용해서 원격 접속하는 것입니다.

### SSH 키 생성하기
ssh-keygen 명령어 형식
```shell
ssh-keygen -t rsa -f ~/.ssh/<KEY_FILENAME> -C <USERNAME>
```
- option `-t` : key 생성 타입을 선택하는 옵션
- option `-f` : 생성할 key 파일의 이름을 설정하는 옵션
- option `-C` : 사용자에 대한 주석을 입력하는 옵션
- `<KEY_FILENAME>` : 개인키 파일 이름
- `<USERNAME>` : GCP VM에서 사용할 사용자명
- 

SSH 키 생성
- 실행 결과를 보면 사용자의 .ssh 디렉토리에 공개키와 개인키가 생성됩니다.
```shell
ssh-keygen -t rsa -f ~/.ssh/gcp_vm -C fineants
```
![](BE/메뉴얼/GCP/refImg/Pasted%20image%2020250829145629.png)

### 생성된 SSH 키를 GCP 콘솔을 통해 서버에 등록하기
생성한 SSH key 쌍 중에서 `.pub` 확장자를 가진 public key를 GCP 콘솔을 통해 서버에 등록해야 합니다.

GCP 콘솔 -> 메타데이터 -> SSH 키 추가
![](BE/메뉴얼/GCP/refImg/Pasted%20image%2020250829150024.png)

SSH 키 값 추가
![](BE/메뉴얼/GCP/refImg/Pasted%20image%2020250829150205.png)

SSH 키 추가 확인
![](BE/메뉴얼/GCP/refImg/Pasted%20image%2020250829150302.png)

### 로컬 SSH 설정 파일에 접속 정보 추가
- 로컬 환경에서 `~/.ssh/config` 파일에 GCP 인스턴스에 SSH 접속하기 위해서 다음과 같이 정보를 추가함
```
Host fineants-gcp
HostName {instance 외부 IP 주소}
User fineants
Port 22
IdentityFile ~/.ssh/gcp_vm
```

SSH 연결 접속 확인
- 실행 결과를 보면 정상적으로 원격 접속하였습니다.
```shell
ssh fineants-gcp
```
![](BE/메뉴얼/GCP/refImg/Pasted%20image%2020250829150822.png)
- fineants@fineants-vm
	- fineants : 사용자이름
	- fineants-vm : 호스트이름


## 백엔드 서버 환경 구성
### 패키지 매니저 업데이트
```shell
sudo apt-get update -y
```
![](BE/메뉴얼/GCP/refImg/Pasted%20image%2020250829152004.png)


### 도커 프로세스 설치
도커 공식 GPG key 추가
```bash
# Add Docker's official GPG key:
sudo apt-get update
sudo apt-get install ca-certificates curl
sudo install -m 0755 -d /etc/apt/keyrings
sudo curl -fsSL https://download.docker.com/linux/ubuntu/gpg -o /etc/apt/keyrings/docker.asc
sudo chmod a+r /etc/apt/keyrings/docker.asc
```

Apt 소스들에 저장소 추가하기
- Docker APT 저장소를 시스템에 등록하는 단계
- 등록하면 `apt-get install docker-ce` 같은 명령으로 공식 Docker 패키지 설치 가능
```bash
# Add the repository to Apt sources:
echo \
  "deb [arch=$(dpkg --print-architecture) signed-by=/etc/apt/keyrings/docker.asc] https://download.docker.com/linux/ubuntu \
  $(. /etc/os-release && echo "${UBUNTU_CODENAME:-$VERSION_CODENAME}") stable" | \
  sudo tee /etc/apt/sources.list.d/docker.list > /dev/null
sudo apt-get update
```

도커 패키지 설치
```shell
sudo apt-get install docker-ce docker-ce-cli containerd.io docker-buildx-plugin docker-compose-plugin
```

도커 설치 확인
```shell
sudo docker run hello-world
```
![](BE/메뉴얼/GCP/refImg/Pasted%20image%2020250829153513.png)

현재 사용자를 docker 그룹에 추가
```shell
sudo usermod -aG docker $USER
```

docker 명령어 실행확인
- docker 명령어 실행확인하기 전에 SSH 재접속하시오.
- 다음 실행 결과를 보면 이제 별도의 `sudo` 명령어 접두사없이 docker 명령어를 사용할 수 있습니다.
```shell
docker ps
```
![](BE/메뉴얼/GCP/refImg/Pasted%20image%2020250829153811.png)


### docker-compose 설치
```shell
sudo apt-get update
sudo apt-get install docker-compose-plugin
sudo curl -L https://github.com/docker/compose/releases/latest/download/docker-compose-$(uname -s)-$(uname -m) -o /usr/local/bin/docker-compose
sudo chmod +x /usr/local/bin/docker-compose
sudo ln -s /usr/local/bin/docker-compose /usr/bin/docker-compose
docker-compose --version
```
![](BE/메뉴얼/GCP/refImg/Pasted%20image%2020250829154344.png)


## swap-memory 설정
현재 메모리 사용 상태 확인
```shell
free -h
```
![](BE/메뉴얼/GCP/refImg/Pasted%20image%2020250829162036.png)

Swap Memory 생성
```shell
sudo fallocate -l 2G ./swapfile
```

Swap Memory 파티션 지정
```shell
sudo mkswap ./swapfile
```

Swap Memory 활성화
```shell
sudo chmod 600 ./swapfile
sudo swapon ./swapfile
```

 /etc/fstab 파일에 Swap Memory 정보 추가
 - `/etc/fstab` 파일은 **리눅스가 부팅될 때 자동으로 마운트해야 할 파일시스템(디스크, 파티션, 스왑 등)의 목록**을 정의하는 설정 파일입니다.
- 리눅스 부팅시 마운트 정보를 가지고 있는 파일입니다. 이 파일에 추가해주어야 swap memory가 유효합니다.
- 파일 제일 아래쪽에 다음 내용을 추가합니다.
```shell
sudo vim /etc/fstab
```

/etc/fstab
```jsx
/home/fineants/swapfile swap swap defaults 0 0
```
- `/home/fineants/swapfile`  
    → 실제 스왑 파일의 경로
- `swap` (두 번째 항목)  
    → 장치 유형을 나타냅니다. 여기서는 "이 파일은 스왑 공간"임을 의미
- `swap` (세 번째 항목)  
    → 파일시스템 타입 (여기서도 "swap"이라고 명시)
- `defaults`  
    → 기본 마운트 옵션 사용
- `0` (다섯 번째 항목)  
    → 덤프(dump) 백업 여부 (스왑에는 필요 없음 → 0)
- `0` (여섯 번째 항목)  
    → fsck(파일시스템 체크) 여부 (스왑은 체크할 필요 없음 → 0)

Swap Memory 실행 결과 확인
```shell
free -h
```
![](BE/메뉴얼/GCP/refImg/Pasted%20image%2020250829162926.png)


docker build
```shell
docker build --platform linux/amd64 -f Dockerfile.production -t fineants/fineants-app:production-test .
```

docker push
```shell
docker push fineants/fineants-app:production-test
```

## MySQL 데이터 GCP Storage 버킷에 백업하기
배경
- GCP Compute Engine VM 위에서 Docker MySQL 컨테이너 실행 중
- 데이터 경로 : /home/ifneants/FineAnts-was/mysql/data
	- 호스트 볼륨에 MySQL 데이터 저장
- 목표: 하루에 한번 MySQL 데이터를 압축 후 GCP Storage 버킷에 업로드

#### 1. VM에 gcloud와 gsutil 설치 확인
```shell
gcloud version
```
![](BE/메뉴얼/GCP/refImg/Pasted%20image%2020250916111845.png)

```shell
gsutil version
```
![](BE/메뉴얼/GCP/refImg/Pasted%20image%2020250916111911.png)

#### 2. GCP 인증(서비스 계정 권장)
VM이 이미 서비스 계정으로 실행중이라면 추가 인증은 불필요합니다.
```shell
gcloud auth list
```
![](BE/메뉴얼/GCP/refImg/Pasted%20image%2020250916112054.png)
- 실행 결과를 보면 한개의 서비스 계정이 등록되어 있는 것을 볼수 있습니다.
- 해당 서비스 계정은 편집자 역할만을 가지고 있습니다. VM 인스턴스가 Storage에 파일을 읽기/쓰기 위해서는 추가적인 권한이 필요함

IAM 서비스에서 해당 서비스 계정에 스토리지 객체 사용자 권한을 추가합니다.
![](BE/메뉴얼/GCP/refImg/Pasted%20image%2020250916125332.png)


#### 3. MySQL 데이터 백업 스크립트 작성
backup_mysql_data.sh
```shell
#!/bin/bash  
# backup_mysql_data.sh  
  
# 백업 대상 디렉토리  
BACKUP_DIR="/home/fineants/FineAnts-was/mysql/data"  
  
# 백업 파일 경로  
BACKUP_FILE="/home/fineants/mysql-backup.gz"  
  
# 메일 설정  
EMAIL="fineants.co.2024@gmail.com"  
SUBJECT="MySQL Backup Status"  
  
# 디렉토리에서 tar로 묶고 gzip 압축  
cd "$BACKUP_DIR" || exit 1  
if sudo tar -cf - . | sudo gzip > "$BACKUP_FILE"; then  
    # GCP Storage 업로드  
    if gsutil cp "$BACKUP_FILE" gs://gcp-fineants-bucket/production/mysql/; then  
        # 로컬 백업 파일 삭제  
        rm -f "$BACKUP_FILE"  
  
        # 성공 메일 전송  
        echo "MySQL data backup completed and uploaded to GCP Storage successfully." | mail -s "$SUBJECT" "$EMAIL"  
        echo "MySQL data backup completed and uploaded to GCP Storage."  
        exit 0  
    else  
        echo "Failed to upload backup to GCP Storage." | mail -s "$SUBJECT" "$EMAIL"  
        exit 2  
    fi  
else  
    echo "Failed to create backup file." | mail -s "$SUBJECT" "$EMAIL"  
    exit 1  
fi
```

실행 권한 부여
```shell
chmod +x ./backup_mysql_data.sh
```

테스트 실행
```shell
./backup_mysql_data.sh
```

#### 4. CronJob 등록
CronJob을 등록하여 하루에 한번 MySQL 데이터 백업 스크립트를 실행하도록 합니다.

cron 설치
```shell
sudo apt install cron -y 
```

cron 편집기 열기
```shell
crontab -e
```

CronJob 등록
```shell
0 0 * * * /home/fineants/FineAnts-was/scripts/backup_mysql_data.sh
```

#### 5. mailutils 설치
```shell
sudo apt-get install mailutils
```
![](BE/메뉴얼/GCP/refImg/Pasted%20image%2020250916144806.png)
- 메일 설정 타입을 2번인 Internet Site로 선택

![](BE/메뉴얼/GCP/refImg/Pasted%20image%2020250916144843.png)

설치 확인
```shell
mail --version
```
![](BE/메뉴얼/GCP/refImg/Pasted%20image%2020250916145403.png)

msmtp, msmtp-mta 설치
```shell
sudo apt install msmtp msmtp-mta
```

msmtprc 설정 파일 작성
```shell
sudo vim ~/.msmtprc
```
```shell
defaults
auth           on
tls            on
tls_trust_file /etc/ssl/certs/ca-certificates.crt
logfile        ~/.msmtp.log

account        google
host           smtp.google.com
port           465
from           {mail}
user           {mail}
password       {password}

account default : google
```

권한 설정
```shell
sudo chmod 600 ~/.msmtprc
```

메일 테스트
```shell
echo "This is the message body" | msmtp -s "This is the subject" fineants.co.2024@gmail.com
```




### 트러블 슈팅: GCS 버킷 파일 업로드 403 문제
문제
- MySQL 데이터를 GCS에 백업 시도시 다음과 같이 403 에러가 발생함
![](BE/메뉴얼/GCP/refImg/Pasted%20image%2020250916141915.png)

원인
- VM 인스턴스의 Cloud API access scope가 Storage에 읽기/쓰기 접근을 하는 스코프가 없기 때문이다.

해결방법
- VM 인스턴스 중지 -> VM 인스턴스 상세 페이지에서 수정 -> 액세스 범위를 "모든 Cloud API에 대한 전체 액세스 허용"으로 선택후 재시작
![](BE/메뉴얼/GCP/refImg/Pasted%20image%2020250916141816.png)

VM 인스턴스 시작 후 다음 명령어를 실행합니다. 해당 명령어를 실행하는 이유는 이전에 gsutil이 사용했던 로컬 사용자 인증 캐시(`~/.gsutil/`) 때문에 새 설정이 적용되지 않을 수 있기 때문입니다.
```shell
sudo rm -r ~/.gsutil/
```


실행 결과
```shell
./backup_mysql_data.sh
```
![](BE/메뉴얼/GCP/refImg/Pasted%20image%2020250916142942.png)
![](BE/메뉴얼/GCP/refImg/Pasted%20image%2020250916143016.png)
- 실행 결과를 보면 gzip 파일이 성공적으로 저장된 것을 볼수 있습니다.






todo
- [x] docker-compose GCP에 맞게 수정
- [x] docker-compose 실행시 spring에 의해서 mysql 데이터베이스 데이터 초기화
- [x] gcp storage에 저장된 프로필 사진을 공개로 수정
- [x] WS와 관련된 소스 코드들을 GCP에 맞게 수정
	- 추상화(인터페이스)를 이용하여 AWS 소스코드들을 그대로 둔채 GCP 소스 코드로 확장
- [x] 인프라 관련 코드들에서 AWS 소스코드를 둔채 GCP로 확장
- [x] AWS 관련 소스 코드
	- 프로필 사진 저장 및 읽기, 삭제
	- 배당금 정보 작성 및 읽기
	- 종목 정보 작성 및 읽기
- compute engine의 mysql 볼륨 데이터를 주기적으로 백업하는 기능 구현

