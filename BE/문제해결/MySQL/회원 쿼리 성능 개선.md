
```java
@Query("select distinct m from Member m left join fetch m.roles "  
    + "where m.profile.email = :email and m.profile.provider = :provider")  
Optional<Member> findMemberByEmailAndProvider(@Param("email") String email, @Param("provider") String provider);
```
- MySQL 클라이언트로 조회시 1163ms가 소요됩니다. 만약 email과 provider에 복합 인덱스를 구성하면 56ms로 개선됨

## 성능 측정
MySQL 클라이언트를 이용하여 쿼리를 실행할때 수행 시간을 측정하였습니다.
```sql
select  
    distinct m.id,  
             m.create_at,  
             m.modified_at,  
             m.email,  
             m.nickname,  
             m.password,  
             m.profile_url,  
             m.provider,  
             mr.member_id,  
             mr.member_role_id,  
             mr.role_role_id  
from  
    member m  
        left join  
    member_role mr  
    on m.id=mr.member_id  
where  
        m.email='dragonbead95@naver.com'  
  and m.provider='local';
```

실행 결과는 다음과 같습니다. 실행 결과를 보면 1252ms가 소요된 것을 볼수 있습니다. 
![[Pasted image 20250430134140.png]]

이번에는 위 쿼리의 실행 계획을 분석해보겠습니다.
![[Pasted image 20250430135003.png]]
member 테이블(m)
- key=null이기 때문에 별도의 인덱스 키를 사용하지 않고 풀 테이블 스캔하였습니다.
- 특이 사항: where 절을 적용되고 있지만, 인덱스를 사용하지 못하고 있으며, distinct 키워드 때문에 임시 테이블이 사용되고 있습니다.

member_role 테이블(mr)
- key 컬럼의 값을 보면 `FK34g...` 값이 있습니다. 이는 member_id 컬럼에 걸린 외래키 인덱스를 사용하고 있습니다.
- ref 컬럼을 보면 fineAnts.m.id 값입니다. 이는 member 테이블의 id 컬럼을 기준으로 조인합니다.

