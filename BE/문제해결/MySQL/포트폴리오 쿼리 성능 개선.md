
## findAllByMemberIdOrderByIdDesc
### JPQL 분석
```java
@Query("select p from Portfolio p where p.member.id = :memberId order by p.id desc")  
List<Portfolio> findAllByMemberIdOrderByIdDesc(@Param("memberId") Long memberId);
```


### 포트폴리오 이름 목록 API 성능 측정
한명의 사용자가 포트폴리오 300만개를 가지고 있다고 가정하고 포트폴리오 이름 목록 API를 조회합니다.
![[Pasted image 20250430160013.png]]

실행 결과는 응답시간을 측정할 수 없었습니다.

### 원인
포트폴리오 이름 목록 API를 처리하지 못한 원인은 서비스 코드에서 300만개의 데이터를 한번에 가져와 메모리에 로딩하고자 하기 때문입니다.
```java
@Transactional(readOnly = true)  
@Cacheable(value = "myAllPortfolioNames", key = "#memberId")  
@Secured("ROLE_USER")  
public PortfolioNameResponse readMyAllPortfolioNames(@NotNull Long memberId) {  
    List<PortfolioNameItem> items = portfolioRepository.findAllByMemberIdOrderByIdDesc(memberId).stream()  
       .sorted(Comparator.comparing(Portfolio::getCreateAt).reversed())  
       .map(PortfolioNameItem::from)  
       .toList();  
    return PortfolioNameResponse.from(items);  
}
```

### 해결방안
- 컨트롤러 메서드에서 기본적으로 설정된 페이징 매개변수(선택적 매개변수)를 설정하여 서비스 코드에서 페이징 조회합니다.
- 일반적으로 사용자가 갖고 있는 포트폴리오의 개수는 많지 않기 때문에 기본적인 페이징 설정을 해도 된다고 생각하였습니다.
- 단, 페이징 처리시 다음 페이지를 조회할 수 있는 응답 처리가 필요합니다.


아쉬운점. 데이터가 존재하는 상태에서 조회시 어떻게 페이징 처리할지 프론트와 고민하지 못한점. 결과적으로 API가 모든 데이터를 반환하는 방식으로 구현될 수 밖에 없었음

- 
