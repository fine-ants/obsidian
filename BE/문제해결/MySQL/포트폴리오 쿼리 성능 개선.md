
## findAllByMemberIdOrderByIdDesc
### JPQL 분석
```java
@Query("select p from Portfolio p where p.member.id = :memberId order by p.id desc")  
List<Portfolio> findAllByMemberIdOrderByIdDesc(@Param("memberId") Long memberId);
```


### 포트폴리오 이름 목록 API 성능 측정
한명의 사용자가 포트폴리오 300만개를 가지고 있다고 가정하고 포트폴리오 이름 목록 API를 조회합니다.
![[Pasted image 20250430160013.png]]

실행 결과는 응답시간을 측정할 수 없었습니다.

### 원인
포트폴리오 이름 목록 API를 처리하지 못한 원인은 서비스 코드에서 300만개의 데이터를 한번에 가져와 메모리에 로딩하고자 하기 때문입니다.
```java
@Transactional(readOnly = true)  
@Cacheable(value = "myAllPortfolioNames", key = "#memberId")  
@Secured("ROLE_USER")  
public PortfolioNameResponse readMyAllPortfolioNames(@NotNull Long memberId) {  
    List<PortfolioNameItem> items = portfolioRepository.findAllByMemberIdOrderByIdDesc(memberId).stream()  
       .sorted(Comparator.comparing(Portfolio::getCreateAt).reversed())  
       .map(PortfolioNameItem::from)  
       .toList();  
    return PortfolioNameResponse.from(items);  
}
```

### 해결방안
- 쿼리 메서드에서 생성일자를 기준으로 내림차순하도록 변경하고 dto 객체를 매핑하도록 변경
- 
