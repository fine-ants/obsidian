
## 배경
- 장시간동안에 종목 현재가 갱신 스케줄러가 5초 간격으로 수행되어 다른 API 및 로그인과 같은 서비스가 느려진 것을 확인하였습니다.
- 스케줄러가 수행되어 외부 API와 통신하여 예상치 못한 메모리 누수(약 7.5MB)도 일부 발생하였습니다.

## 원인
- 종목 현재가 갱신 스케줄러가 현재 36개 정도의 종목의 현재가를 갱신하면서 MySQL 데이터베이스, WebClient 통신, Redis를 참조를 지속적으로 수행하기 때문에 다른 API 처리에 성능 저하가 발생합니다. 예를 들어 로그인 같은 경우에는 장시간이 아닌 동안에는 1~2초 정도 소요되지만, 장시간동안에는 약 20초정도 소요됩니다.

## 개선방안
- 현재 종목 현재가 갱신 스케줄러가 갱신하는 종목들은 회원들의 포트폴리오 종목 및 관심 종목들입니다. 하지만 사용자가 로그인하고 있지 않아도 스케줄러는 지속적으로 이 타겟팅된 종목들을 갱신하고 있습니다.
- **현재 접속중인 사용자들의 종목만을 타겟팅하여 현재가를 갱신하도록 합니다.**
	- 사용자들의 종목은 포트폴리오에 등록된 종목들과 관심 종목들입니다.
	- 타켓팅된 종목들은 Redis 저장소에 `Sorted Set`에 저장 및 관리합니다.
	- 타켓팅된 종목들의 활성 시간은 5분입니다.
	- 이렇게 좀더 타켓팅된 종목들만을 갱신하여 부하를 감소시킵니다.
- **Cache-Aside + Write-Through 하이브리드 전략 사용**
	- 사용자가 특정 종목을 조회할 때의 로직을 다음과 같이 설계합니다.
	- 1. Redis 확인: 먼저 Redis에서 종목의 현재가를 조회합니다.
	- 2. 유효성 검증: 데이터가 존재하고 설정한 Freshness(예: 5초)이내라면 즉시 반환합니다.
	- 3. On-Demand 갱신: 만약 데이터가 없거나 5초가 지났다면, API 서버가 직접 외부 API를 호출하는 것이 아니라 "갱신 이벤트"를 발행하고 현재 있는 값을 반환(Stale-while-revalidate)하거나, 잠시 대기하여 최신값을 보여줍니다.
		- 캐시 저장소에 종목의 현재가 또는 종가 데이터가 아예 없는 경우에는 동기적으로 실행되는 이벤트를 발행하고, 캐시 값이 존재하면 비동기적으로 이벤트를 발행하고, 캐시된 값을 반환합니다. 해당 캐시된 값은 신선도가 떨어지는 값이입니다.

---

실시간 활성 종목 기반의 종목 현재가 갱신 시스템 개선
문제 상황 및 배경
- 비효율적인 종목 갱신: 기존 시스템은 전체 회원의 보유 종목(약 40종)을 대상으로 5초 간격으로 무조건적인 갱신을 수행.
- 시스템 가용성 저하: 장(Market) 거래 시간 내 외부 API, DB, Redis 통신 부하로 인하여 로그인 및 주요 API 응답 속도가 평소 1~2초에서 20초로 급격히 저하.
- 메모리 누수: 외부 통신 과정에서 주기적인 메모리 누수(약 7.5MB) 발생 및 불필요한 네트워크 비용 초래함.

문제 원인 분석
- 실시간 현재가를 요청하지 않은 종목까지 갱신하며 발생하는 CPU 및 메모리 점유율 상승

해결 방안 및 구현
- 활성 종목(Active Stock) 관리 전략 도입
	- 사용자가 현재 참조 중인 종목(포트폴리오, 관심 종목, 종목 상세 조회 등)만 갱신 대상으로 필터링.
	- Redis Sorted Set을 활용하여 종목별 마지막 참조 시간을 Score로 관리, 5분 이상 미참조 시 자동으로 갱신 대상에서 제외하여 관리 효율을 최적화.
- Cache-Aside + Write-Through 하이브리드 전략 사용
	- 


개선 배경
- 기존 갱신 스케줄러는 모든 회원이 가진 포트폴리오에 등록된 모든 종목(약 30~40 종목)들을 대상으로 5초 간격으로 종목 현재가를 갱신하고 있습니다. 이로 인해서 불필요한 현재가 갱신을 수행하고 있고, 다른 API 및 로그인 성능에도 영향을 미치고 있습니다.
- 갱신 스케줄러가 작동하지 않는 장시간 외에는 로그인과 같은 작업이 1~2초 이내로 이루어지는 반면에 장시간 동안에는 약 20초 정도 소요되는 것을 확인하였습니다.
- 갱신 스케줄러가 작동하는 과정에서 외부 API 서버와 통신하여 예상치 못한 메모리 누수(약 7.5MB)도 발생하였습니다.
원인
- API의 성능 저하의 원인으로 종목 현재가 갱신 스케줄러가 지속적으로 수행하며 외부 API, 데이터베이스, Redis와 같은 서비스와 통신하면서 성능 저하가 발생합니다.
개선 작업
- 현재 접속중인 사용자들이 참조하는 종목만을 대상으로 하여 종목의 현재가를 갱신하도록 합니다.
- 사용자들이 참조하는 종목이란 포트폴리오에 등록된 종목, 관심 종목, 상세 검색한 종목과 같은 서비스 이용시 참조되는 종목들입니다.
- 실시간으로접속중인 사용자가 참조하는 종목들을 활성화된 종목(ActiveStock)이라고 정의하였습니다.
- 활성화된 종목들을 Redis 저장소에 Sorted Set 컬렉션에 저장 및 관리합니다.
- 해당 컬렉션에 저장되는 데이터에 마지막 업데이트 시간을 저장하여 활성 시간 범위를 5분으로 설정합니다.
- 서버는 저장된 활성화된 종목 데이터의 마지막 업데이트 시간이 5분을 초과하면 더이상 현재가를 갱신할 필요가 없는 종목이라고 판단하여 현재가 갱신 대상으로 보지 않도록 합니다.
- Cache-Aside + Write-Through 복합 전략을 사용하여 개선합니다.
- 서버가 종목의 현재가 조회시 우선적으로 Redis 저장소를 먼저 조회합니다. 캐시 데이터가 없다면 동기적으로 외부 API와 통신하여 현재가를 조회하고 캐시 저장소에 저장합니다. 캐시 데이터가 존재하지만 신선도(Freshness)가 5초 이내라면 비동기적으로 종목 현재가 갱신 이벤트를 발행하고, 기존 현재가를 반환합니다.
  

성과
- 불필요한 종목의 현재가를 갱신하는 것이 아닌 갱신이 필요한 종목만을 대상으로 현재가를 갱신할 수 있게 되었습니다.
- 현재가를 갱신할 종목의 개수가 줄어들기 때문에 CPU 사용량 및 메모리 사용량이 줄어들어 다른 API 및 로그인 인증과 같은 성능 향상을 받았습니다.
- Redis에 필요한 종목 현재가만을 저장하기 때문에 메모리 사용량을 절약할 수 있었습니다.