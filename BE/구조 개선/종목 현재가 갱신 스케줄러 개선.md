
## 배경
- 장시간동안에 종목 현재가 갱신 스케줄러가 5초 간격으로 수행되어 다른 API 및 로그인과 같은 서비스가 느려진 것을 확인하였습니다.
- 스케줄러가 수행되어 외부 API와 통신하여 예상치 못한 메모리 누수(약 7.5MB)도 일부 발생하였습니다.

## 원인
- 종목 현재가 갱신 스케줄러가 현재 36개 정도의 종목의 현재가를 갱신하면서 MySQL 데이터베이스, WebClient 통신, Redis를 참조를 지속적으로 수행하기 때문에 다른 API 처리에 성능 저하가 발생합니다. 예를 들어 로그인 같은 경우에는 장시간이 아닌 동안에는 1~2초 정도 소요되지만, 장시간동안에는 약 20초정도 소요됩니다.

## 개선방안
- 현재 종목 현재가 갱신 스케줄러가 갱신하는 종목들은 회원들의 포트폴리오 종목 및 관심 종목들입니다. 하지만 사용자가 로그인하고 있지 않아도 스케줄러는 지속적으로 이 타겟팅된 종목들을 갱신하고 있습니다.
- **현재 접속중인 사용자들의 종목만을 타겟팅하여 현재가를 갱신하도록 합니다.**
	- 사용자들의 종목은 포트폴리오에 등록된 종목들과 관심 종목들입니다.
	- 타켓팅된 종목들은 Redis 저장소에 `Sorted Set`에 저장 및 관리합니다.
	- 타켓팅된 종목들의 활성 시간은 5분입니다.
	- 이렇게 좀더 타켓팅된 종목들만을 갱신하여 부하를 감소시킵니다.
- **Cache-Aside + Write-Through 하이브리드 전략 사용**
	- 사용자가 특정 종목을 조회할 때의 로직을 다음과 같이 설계합니다.
	- 1. Redis 확인: 먼저 Redis에서 종목의 현재가를 조회합니다.
	- 2. 유효성 검증: 데이터가 존재하고 설정한 Freshness(예: 5초)이내라면 즉시 반환합니다.
	- 3. On-Demand 갱신: 만약 데이터가 없거나 5초가 지났다면, API 서버가 직접 외부 API를 호출하는 것이 아니라 "갱신 이벤트"를 발행하고 현재 있는 값을 반환(Stale-while-revalidate)하거나, 잠시 대기하여 최신값을 보여줍니다.
		- 캐시 저장소에 종목의 현재가 또는 종가 데이터가 아예 없는 경우에는 동기적으로 실행되는 이벤트를 발행하고, 캐시 값이 존재하면 비동기적으로 이벤트를 발행하고, 캐시된 값을 반환합니다. 해당 캐시된 값은 신선도가 떨어지는 값이입니다.

---

실시간 활성 종목 기반의 종목 현재가 갱신 시스템 개선
문제 상황 및 배경
- 비효율적인 종목 갱신: 기존 시스템은 전체 회원의 보유 종목(약 36종)을 대상으로 스케줄러를 이용하여 5초 간격으로 무조건적인 갱신을 수행.
	- 환경: GCP e2-micro(2 vCPU, 1GB RAM) / Docker 환경 기준
	- 대상: 36개 종목의 현재가 갱신, 1회 갱신 사이클 소요 시간
	- 결과: 36031ms (36초)
- 시스템 가용성 저하: 장(Market) 거래 시간 내 외부 API, DB, Redis 통신 부하로 인하여 로그인 및 주요 API 응답 속도가 평균 1초에서 20초로 저하.
	- todo: 장시간 내, 외의 로그인 및 API 수행시간 측정
- 메모리 누수: 외부 통신 과정에서 주기적인 메모리 누수(약 7.5MB) 발생 및 불필요한 네트워크 비용 초래함.

기존 시스템 수행 시간 측정
- 종목 현재가 갱신 스케줄러 수행 시간
- 

문제 원인 분석
- 실시간 종목 현재가가 필요없는 비활성 종목까지 일괄 갱신 대상에 포함시켜서 장시간 내에 시스템 전체의 CPU 및 메모리 리소스를 과다하게 점유하는 것이 원인입니다.

해결 방안 및 구현
- 활성 종목(Active Stock) 관리 전략 도입
	- 사용자가 현재 참조 중인 종목(포트폴리오, 관심 종목, 종목 상세 조회 등)만 갱신 대상으로 필터링.
	- Redis Sorted Set을 활용하여 종목별 마지막 참조 시간을 Score로 관리, 5분 이상 미참조 시 자동으로 갱신 대상에서 제외하여 관리 효율을 최적화.
- Cache-Aside + Write-Through 전략 사용
	- Read: Redis 우선 조회로 DB/API 부하 분산
	- Refresh: 현재가가 존재해도 신선도(5초)가 낮을 경우, 사용자에게 즉시 기존 현재가를 반환하고 비동기(이벤트 기반) 방식으로 현재가를 갱신하여 사용자 경험을 개선
- AOP 기반의 관심사 분리
	- 9개의 관련 API에 애노테이션 방식을 사용한 AOP(Aspect)를 적용하여 활성 종목 등록 로직의 중복적인 코드를 제거하고 선언적으로 관리함.

주요 성과
- 성능 최적화: 갱신 대상 종목 선별을 통해서 장 시간 내 API 응답 시간 95% 단축(20초 -> 1초).
	- todo: 개선 전후, 로그인 수행시간 측정
	- 장시간 내, 일반 로그인 성능 측정 결과: 10명의 사용자가 1분 동안 성능 테스트 결과, 평균 응답 시간은 약 1.3초로 측정됨
- 자원 효율성: 불필요한 API 호출 및 Redis 데이터 적재를 최소화하여 CPU 및 메모리 사용량 절감.
	- todo: 개선 전후, 서버의 CPU 및 메모리 사용량 측정
		- 프로메테우스 및 그라파나로 사용량 측정
	- 
	- todo: 개선 전후, Redis 메모리 사용량 측정
- 안정성 확보: 동기적 갱신을 비동기 이벤트 방식으로 전환하여 외부 API 장애 시에도 서비스 영향을 최소화.
