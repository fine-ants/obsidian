
## 배경
- 장시간동안에 종목 현재가 갱신 스케줄러가 5초 간격으로 수행되어 다른 API 및 로그인과 같은 서비스가 느려진 것을 확인하였습니다.
- 스케줄러가 수행되어 외부 API와 통신하여 예상치 못한 메모리 누수(약 7.5MB)도 일부 발생하였습니다.

## 원인
- 종목 현재가 갱신 스케줄러가 현재 36개 정도의 종목의 현재가를 갱신하면서 MySQL 데이터베이스, WebClient 통신, Redis를 참조를 지속적으로 수행하기 때문에 다른 API 처리에 성능 저하가 발생합니다. 예를 들어 로그인 같은 경우에는 장시간이 아닌 동안에는 1~2초 정도 소요되지만, 장시간동안에는 약 20초정도 소요됩니다.

## 개선방안
- 현재 종목 현재가 갱신 스케줄러가 갱신하는 종목들은 회원들의 포트폴리오 종목 및 관심 종목들입니다. 하지만 사용자가 로그인하고 있지 않아도 스케줄러는 지속적으로 이 타겟팅된 종목들을 갱신하고 있습니다.
- **현재 접속중인 사용자들의 종목만을 타겟팅하여 현재가를 갱신하도록 합니다.**
	- 사용자들의 종목은 포트폴리오에 등록된 종목들과 관심 종목들입니다.
	- 타켓팅된 종목들은 Redis 저장소에 `Sorted Set`에 저장 및 관리합니다.
	- 이렇게 좀더 타켓팅된 종목들만을 갱신하여 부하를 감소시킵니다.
- **Cache-Aside + Write-Through 하이브리드 전략 사용**
	- 사용자가 특정 종목을 조회할 때의 로직을 다음과 같이 설계합니다.
	- 1. Redis 확인: 먼저 Redis에서 종목의 현재가를 조회합니다.
	- 2. 유효성 검증: 데이터가 존재하고 설정한 Freshness(예: 5초)이내라면 즉시 반환합니다.
	- 3. On-Demand 갱신: 만약 데이터가 없거나 5초가 지났다면, API 서버가 직접 외부 API를 호출하는 것이 아니라 "갱신 이벤트"를 발행하고 현재 있는 값을 반환(Stale-while-revalidate)하거나, 잠시 대기하여 최신값을 보여줍니다.



