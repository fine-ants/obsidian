Spring Security 라이브러리를 추가하면서 소셜 로그인 기능을 다시 구현한 이유는 무엇인가요?

## 개요
이 글에서는 기존 시스템에서 직접 구현한 OAuth 2.0 기반 소셜 로그인 기능을, Spring Security 라이브러리를 도입하면서 해당 프레임워크에 맞게 재구현하게 된 배경과 이유를 소개합니다. 직접 구현한 방식의 한계와 유지보수성 문제를 어떻게 Spring Security가 해결해주었는지도 함께 다룹니다.

## 직접 구현한 소셜 로그인 방식
- 어떤 방식으로 구현하였는지(OAuth 2.0 흐름 직접 처리, 토큰 관리 등)
- 구현 당시 어떤 이유로 직접 구현을 했는지를 설명

어떤 방식으로 구현할때 무엇을 설명해야 하는가?
기존에 구현한 소셜 로그인의 수행과정을 설명. 
기존에는 사용자가 접속할 인증 URL을 생성하기 위해서 별도의 API를 구현하였습니다. 해당 인증 URL에는 사용자가 로그인해야할 소셜 플랫폼의 로그인 URL과 인가 코드를 받은 다음에 전달해야할 리다이렉션 주소가 포함되어 있습니다.

## 직접 구현 방식의 한계
- 유지 보수의 어려움(예: 중복 코드, 보안 로직 누락 위험 등)
- 확장성과 일관성의 부족
- 테스트와 디버깅의 어려움

## Spring Security 도입 배경
- 어떤 구조로 변경했는지
- 커스터마이징한 부분이 있다면 간략히 소개
- 도입 과정에서 겪은 이슈나 고민

## 유지보수성과 확장성 측면에서의 개선 효과
- 코드 구조 정리
- 보안 정책 일관성
- 기능 확장이나 정책 변경 시 유연함

## 마무리 및 회고
- 이번 리팩토링의 의의
- 얻은 교훈 또는 다음에 적용할 방향



