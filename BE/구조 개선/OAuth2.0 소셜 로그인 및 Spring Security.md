Spring Security 라이브러리를 추가하면서 소셜 로그인 기능을 다시 구현한 이유는 무엇인가요?

## 개요
이 글에서는 기존 시스템에서 직접 구현한 OAuth 2.0 기반 소셜 로그인 기능을, Spring Security 라이브러리를 도입하면서 해당 프레임워크에 맞게 재구현하게 된 배경과 이유를 소개합니다. 직접 구현한 방식의 한계와 유지보수성 문제를 어떻게 Spring Security가 해결해주었는지도 함께 다룹니다.

## 직접 구현한 소셜 로그인 방식
- 어떤 방식으로 구현하였는지(OAuth 2.0 흐름 직접 처리, 토큰 관리 등)
- 구현 당시 어떤 이유로 직접 구현을 했는지를 설명

직접 구현한 소셜 로그인 방식은 사용자의 로그인 요청을 컨트롤러에서 받은 다음에 서비스 레이어에서 전부 처리하는 방식이었습니다. 로그아웃 같은 경우에는 
기능 구현 당시에 Spring Security 라이브러리를 처음부터 도입하여 기능을 구현하는 선택지도 있었지만, 라이브러리 숙련도가 미숙하였고 사용자에 대한 인증 여부만 처리해도 될 것이라고 판단하였습니다.

## 직접 구현 방식의 한계
- 유지 보수의 어려움(예: 중복 코드, 보안 로직 누락 위험 등)
- 확장성과 일관성의 부족
- 테스트와 디버깅의 어려움

## Spring Security 도입 배경
- 어떤 구조로 변경했는지
- 커스터마이징한 부분이 있다면 간략히 소개
- 도입 과정에서 겪은 이슈나 고민

## 유지보수성과 확장성 측면에서의 개선 효과
- 코드 구조 정리
- 보안 정책 일관성
- 기능 확장이나 정책 변경 시 유연함

## 마무리 및 회고
- 이번 리팩토링의 의의
- 얻은 교훈 또는 다음에 적용할 방향



