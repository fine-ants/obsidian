Spring Security 라이브러리를 추가하면서 소셜 로그인 기능을 다시 구현한 이유는 무엇인가요?

## 개요
이 글에서는 기존 시스템에서 직접 구현한 OAuth 2.0 기반 소셜 로그인 기능을, Spring Security 라이브러리를 도입하면서 해당 프레임워크에 맞게 재구현하게 된 배경과 이유를 소개합니다. 직접 구현한 방식의 한계와 유지보수성 문제를 어떻게 Spring Security가 해결해주었는지도 함께 다룹니다.

## 직접 구현한 소셜 로그인 방식
- 어떤 방식으로 구현하였는지(OAuth 2.0 흐름 직접 처리, 토큰 관리 등)
- 구현 당시 어떤 이유로 직접 구현을 했는지를 설명

어떤 방식으로 구현할때 무엇을 설명해야 하는가?
기존에 구현한 소셜 로그인의 수행과정을 설명. 
기존에는 사용자가 접속할 인증 URL을 생성하기 위해서 별도의 API를 구현하였습니다. 해당 인증 URL에는 사용자가 로그인해야할 소셜 플랫폼의 로그인 URL과 인가 코드를 받은 다음에 전달해야할 리다이렉션 주소가 포함되어 있습니다.

기존 직접 구현한 소셜 로그인 방식의 수행 과정은 다음과 같습니다.
1. 사용자가 소셜 플랫폼에 로그인하기 위한 URL 주소에 접근하기 위해서 서버에 주소를 요청한다.
2. 서버는 소셜 플랫폼에 맞는 인증 URL을 리다이렉션 주소와 같이 포함하여 응답합니다.
3. 사용자는 인증 URL에 접속하여 소셜 플랫폼에 로그인 한 다음에 인가 코드를 받습니다. 그 다음에 리다이렉션 주소로 요청하면서 인가 코드를 같이 전달하면서 로그인을 요청합니다.
4. 서버는 전달받은 인가 코드를 이용하여 인증 서버로부터 액세스 토큰을 전달받고 액세스 토큰으로 사용자의 정보를 질의합니다.
5. 서버는 질의한 사용자의 정보를 처리하여 JWT로 발급한 다음에 ResponseBody에 담아서 응답합니다.

기존 직접 구현한 소셜 로그인 방식은 인가코드 발급을 위한 인증 URL 생성 API 및 로그인 처리를 

## 직접 구현 방식의 한계
- 유지 보수의 어려움(예: 중복 코드, 보안 로직 누락 위험 등)
- 확장성과 일관성의 부족
- 테스트와 디버깅의 어려움

## Spring Security 도입 배경
- 어떤 구조로 변경했는지
- 커스터마이징한 부분이 있다면 간략히 소개
- 도입 과정에서 겪은 이슈나 고민

## 유지보수성과 확장성 측면에서의 개선 효과
- 코드 구조 정리
- 보안 정책 일관성
- 기능 확장이나 정책 변경 시 유연함

## 마무리 및 회고
- 이번 리팩토링의 의의
- 얻은 교훈 또는 다음에 적용할 방향



