
## 현재 방식(String 개별 저장) 분석
Redis 저장소에 종목의 현재가를 key-value 방식으로 각각 저장하고 있습니다. 예를 들어 다음과 같이 각각 저장하고 있습니다.
![](refImg/Pasted%20image%2020260123141019.png)

장점
- 개별 제어 용이: 특정 종목만 만료시간(TTL)을 다르게 주어서 삭제하기 쉬움
- 단순함: 구조가 단순하여 구현이 빠름

단점
- 메모리 오버헤드: Redis의 모든 key는 메타데이터를 가집니다. 100개의 key가 생성되면, 100배의 메타데이터 공간이 낭비됨.
- 네트워크 오버헤드: 100개의 종목을 조회할때 GET을 100번 호출하거나 MGET을 써야 하므로 통신 횟수가 늘어남.


## 개선안: Redis Hash 사용
많은 종목의 현재가를 하나의 key안에 필드 형태로 저장하는 방식입니다.
- Key: current_prices
- Field: {tickerSymbol}
- Value: {price}

String 방식보다 Hash 방식이 효율적인 이유
- 메모리 절약
	- Redis는 내부적으로 `ziplist`라는 압축 구조를 사용하여 작은 데이터가 모여있는 Hash를 매우 효율적으로 저장합니다. 메타데이터 중복이 사라져 메모리 사용량이 크게 줄어듭니다.
- 한번에 조회 가능
	- `HGETALL current_prices` 한 번으로 100개 종목의 시세를 즉시 가져올 수 있습니다. (네트워크 Round-trip 획기적 감소)
- 관리 편의성
	- "현재가 집합"이라는 개념으로 묶여 있어 관리가 명확합니다.

String vs Hash 방식 비교

| 구분        | 개별 String (현재 방식)    | Hash (개선안 방식)        |
| --------- | -------------------- | -------------------- |
| 메모리 효율    | 낮음 (Key마다 오버헤드 발생)   | 높음 (하나의 Key로 통합 관리)  |
| 네트워크 성능   | 보통 (MGET 사용시 개선 가능)  | 우수 (HGETALL 한번으로 해결) |
| 개별 TTL 설정 | 가능 (종목별 만료시간 다르게 가능) | 불가능 (Key 전체에만 설정 가능) |
| 추천 시나리오   | 종목별로 수명이 완전히 다른 경우   | 대부분의 현재가 갱신 시나리오     |

