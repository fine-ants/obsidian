- [[#닉네임 중복 검사|닉네임 중복 검사]]
- [[#이메일 중복 검사|이메일 중복 검사]]
- [[#검증 코드 전송|검증 코드 전송]]
- [[#검증 코드 검사|검증 코드 검사]]
- [[#일반 회원가입|일반 회원가입]]
- [[#프로필 조회|프로필 조회]]
- [[#회원 프로필 수정|회원 프로필 수정]]
- [[#회원 비밀번호 변경|회원 비밀번호 변경]]
- [[#계정 삭제|계정 삭제]]
- [[#인증|인증]]
- [[#알림|알림]]




## 닉네임 중복 검사
### 기능 개요
- 사용자는 닉네임을 입력하여 해당 닉네임이 다른 회원과 중복되는지 확인할 수 있습니다.
- 모든 회원의 닉네임은 고유해야 하며, 중복된 닉네임은 사용할 수 없습니다.
- 닉네임 중복검사 기능은 **회원가입 시** 또는 **프로필 정보 변경 시** 수행됩니다.
- 서버는 전달받은 닉네임의 형식 검증 및 데이터베이스 중복 여부를 확인하여 결과를 응답합니다.

### 기능적 요구사항
입력 형식

| 항목       | 필수 여부 | 설명                 |
| -------- | ----- | ------------------ |
| nickname | 필수    | 중복 여부를 확인하기 위한 닉네임 |

입력 규칙
- 닉네임은 **한글, 영문 대소문자, 숫자**로만 구성되어야 합니다.
- 닉네임의 길이는 **2자 이상 100자 이하**여야 합니다.
- **공백 및 특수문자는 허용되지 않습니다.**
- **대소문자는 구분되지 않습니다.**
- 닉네임 형식은 다음 정규식을 만족해야 합니다.
```regex
^[가-힣a-zA-Z0-9]{2,100}$
```

처리 흐름
1. 사용자는 닉네임을 입력하고 서버에 중복 검사를 요청합니다.
2. 서버는 전달받은 닉네임의 형식을 검증합니다.
3. 서버는 닉네임을 소문자로 변환하여(대소문자 구분 없음) 데이터베이스에서 동일한 닉네임이 존재하는지 조회합니다.
4. 동일한 닉네임이 존재하면 “중복” 응답을, 존재하지 않으면 “사용 가능” 응답을 반환합니다.

### 비기능적 요구사항

| 항목      | 설명                                                              |
| ------- | --------------------------------------------------------------- |
| 응답 시간   | 중복 검사 요청은 평균 1초 이내에 응답해야 합니다.                                   |
| 데이터 일관성 | 닉네임은 데이터베이스의 `nickname` 컬럼에 **UNIQUE 제약조건**을 적용하여 중복 저장을 방지합니다. |
| 보안성     | 입력값 검증을 통해 SQL Injection, Script Injection 등의 보안 취약점을 예방해야 합니다. |
| 가용성     | 시스템은 회원가입 및 프로필 수정 시점에 항상 닉네임 중복 검사 기능을 제공해야 합니다.               |
| 로깅      | 중복 검사 요청 및 결과는 서버 로그에 기록하지 않습니다. (개인정보 보호 목적)                   |

### 예외 처리

| 상황          | 설명                   | 처리 방식                          |
| ----------- | -------------------- | ------------------------------ |
| 닉네임 형식 오류   | 닉네임이 입력 형식을 만족하지 않음  | `400 Bad Request` 응답           |
| 닉네임이 이미 존재함 | 동일한 닉네임이 데이터베이스에 존재함 | `409 Conflict` 응답              |
| 서버 내부 오류    | DB 연결 실패 등 내부 예외 발생  | `500 Internal Server Error` 응답 |


---

## 이메일 중복 검사
### 기능 개요
- 사용자는 이메일을 입력하여 로컬 회원들의 이메일 중에서 중복되는 이메일이 존재하는지 확인 할 수 있습니다.
- 소셜 인증 플랫폼으로 가입한 회원을 제외한 로컬 회원들들 중에서 이메일은 고유해야 합니다.
- 서버는 로컬 회원들의 이메일 중에서 중복되는 이메일이 존재하는 확인합니다.

### 기능적 요구사항
입력 형식

| 항목    | 필수 여부 | 설명                 |
| ----- | ----- | ------------------ |
| email | 필수    | 중복 여부를 확인하기 위한 이메일 |
입력 규칙
- 공백은 허용하지 않습니다.
- 이메일은 대소문자를 구분되지 않습니다.
- 이메일 형식은 다음 정규식을 만족해야 합니다.
```
^[a-zA-Z0-9._%+-]+@[a-zA-Z0-9.-]+\.[a-zA-Z]{2,6}$
```

처리 흐름
1. 사용자는 이메일을 제출하며 서버에 이메일 중복 검사를 요청합니다.
2. 서버는 입력받은 이메일을 가지고 중복되는지 검사합니다.
3. 서버는 중복되는 이메일이면 예외를 발생시켜 응답하고, 중복되지 않으면 중복되지 않았다고 응답합니다.

### 비기능적 요구사항

| 항목      | 설명                                                                                |
| ------- | --------------------------------------------------------------------------------- |
| 응답 시간   | 이메일 중복 검사 요청은 평균 1초 이내에 처리되어야 합니다.                                                |
| 데이터 일관성 | 이메일은 로컬 회원의 `email` 컬럼에 **UNIQUE 제약조건**을 적용하여 중복 저장을 방지해야 합니다.                    |
| 보안성     | 이메일 입력값은 **서버 단에서 정규식 검증**을 수행하여 SQL Injection, Script Injection 등의 공격을 방지해야 합니다. |
| 정확성     | 이메일 비교시 대소문자를 구분하지 않도록(lowercase 변환 후) 비교해야 합니다.                                  |
| 가용성     | 서비스는 회원가입 또는 이메일 변경 시 항상 이메일 중복 검사 기능을 제공해야 합니다.                                  |
| 로그 정책   | 이메일 중복 검사 요청 및 결과는 **로그에 이메일 전체를 저장하지 않습니다.** (개인정보 보호 목적)                        |
| 확장성     | 추후 소셜 회원(email 중복 제외)을 포함하거나 구분하는 로직을 확장할 수 있도록 설계되어야 합니다.                        |

### 예외 처리

| 상황          | 설명                                              | 처리 방식                          |
| ----------- | ----------------------------------------------- | ------------------------------ |
| 이메일 형식 오류   | 이메일이 정규식을 만족하지 않거나 잘못된 형식으로 입력됨                 | `400 Bad Request` 응답           |
| 이메일 중복      | 동일한 이메일이 회원 테이블에 이미 존재함                         | `409 Conflict` 응답              |
| 소셜 회원 중복 예외 | 동일 이메일이 존재하지만 소셜 계정이므로 예외적으로 허용해야 함 (정책적 구분 필요) | `200 OK` 응답                    |
| 서버 내부 오류    | DB 연결 실패, 예기치 못한 예외 등                           | `500 Internal Server Error` 응답 |

---

## 검증 코드 전송
### 기능 개요
- 사용자는 이메일을 입력하면 회원가입을 위한 검증 코드를 전송 받을 수 있습니다.
- 시스템은 이메일을 입력받으면 이메일로 검증 코드를 전송합니다.


### 기능적 요구사항
입력 형식

| 항목    | 필수 여부 | 설명             |
| ----- | ----- | -------------- |
| email | 필수    | 검증 코드를 수신할 이메일 |

입력 규칙
- 검증 코드는 6자리 숫자로 구성되어야 합니다.
- 예를 들어 000000 ~ 999999 사이의 수로 구성됩니다.

처리 흐름
1. 사용자는 이메일을 입력하고 검증 코드 전송을 요청합니다.
2. 시스템은 랜덤한 검증 코드를 생성한 다음에 저장소에 저장한 다음에 사용자가 제출한 이메일로 검증 코드를 전송합니다.
3. 사용자는 이메일로 검증 코드를 수신받습니다.

### 비기능적 요구사항

| 항목       | 설명                                                                                           |
| -------- | -------------------------------------------------------------------------------------------- |
| 응답 시간    | 검증 코드 요청시 평균 3초 이내에 이메일 전송 응답을 반환해야 합니다.(이메일 발송 완료 여부는 비동기적으로 처리 가능)                         |
| 보안성      | - 검증 코드는 서버측에서만 생성되어야 하며, 클라이언트에서 직접 생성할 수 없습니다.<br>- 검증 코드는 암호화 또는 난수 기반 안전한 방식으로 생성해야 합니다. |
| 유효 기간    | 검증 코드는 발급 시점으로부터 **5분간 유효**해야 하며, 이후 자동 만료되어야 합니다.                                           |
| 중복 요청 제한 | 동일 이메일 주소로의 검증 코드 요청은 일정 시간(예: 1분) 내에 중복 요청이 불가해야 합니다.(Rate Limiting 적용)                     |
| 데이터 일관성  | - 발급된 검증 코드는 데이터 저장소(Redis 등)에 저장해야 합니다.<br>- 동일 이메일에 대한 이전 코드가 존재하는 경우 새로운 검증 코드로 갱신해야 합니다. |
| 가용성      | 이메일 발송 시스템(SMTP 또는 외부 메일 서비스)은 **장애 시 재시도 로직** 또는 **Failover 서비스**를 지원해야 합니다.                |
| 로그 정책    | - 검증 코드 자체는 로그에 직접 저장하지 않습니다.<br>- 요청 성공/실패 여부 및 이메일 수신자 정보 일부만 로깅합니다.                       |
| 확장성      | - 향후 SMS, 푸시 알림 등 다른 인증 채널 추가가 용이하도록 인터페이스 기반 설계해야 합니다.                                      |
| 트랜잭션 관리  | 이메일 전송 성공 시에만 검증 코드 저장이 완료되어야 하며, 실패 시 롤백되어야 합니다.                                            |

### 예외 처리


| 상황                     | 설명                                  | 처리 방식                           |
| ---------------------- | ----------------------------------- | ------------------------------- |
| 이메일 형식 오류              | 이메일이 정규식을 만족하지 않거나 유효하지 않은 형식으로 입력됨 | `400 Bad Request` 응답            |
| 이메일 누락                 | 요청 본문에 `email` 필드가 누락됨              | `400 Bad Request` 응답            |
| 과도한 요청 (Rate Limit 초과) | 동일 이메일에 대해 짧은 시간 내에 반복 요청 발생        | `429 Too Many Requests` 응답      |
| 이메일 발송 실패              | 메일 서버 오류 또는 외부 이메일 서비스 장애로 인한 전송 실패 | `500 Internal Server Error`  응답 |
| 내부 서버 오류               | 서버 내부 로직 또는 저장소 접근 실패               | `500 Internal Server Error` 응답  |

---

## 검증 코드 검사
### 기능 개요
- 사용자는 메일로 수신받은 검증 코드를 시스템에 제출하여 검사를 요청합니다.
- 서버는 사용자로부터 받은 검증 코드와 서버가 가지고 있는 검증 코드가 일치하는지 검사합니다.

### 기능적 요구사항
입력 형식

| 항목    | 필수 여부 | 설명                  |
| ----- | ----- | ------------------- |
| email | 필수    | 검증 코드의 키값에 해당하는 이메일 |
| code  | 필수    | 매칭할 검증 코드 값         |

처리 흐름
1. 사용자는 이메일과 검증 코드를 제출하여 이메일에 따른 검증 코드가 일치하는지 검사 요청합니다.
2. 서버는 저장소에 이메일에 따른 검증 코드가 일치하는지 검사합니다.
3. 검증코드가 일치하지 않는다면 예외를 발생시키고 에러 응답합니다.
4. 검증코드가 일치하면 일치한다고 응답합니다.

### 비기능적 요구사항

| 구분       | 내용                                                                                                              |
| -------- | --------------------------------------------------------------------------------------------------------------- |
| 보안성      | - 검증 코드는 암호화되지 않은 평문으로 로그에 남아서는 안된다<br>- 동일 이메일로 너무 많은 검증 실패가 발생할 경우 일정 시간 동안 검증 요청을 차단합니다. (Brute force 공격 방지) |
| 일회성 처리   | 검증 성공 시 해당 이메일의 검증 코드는 즉시 삭제되어야 하며, 동일 코드를 재사용할 수 없습니다.                                                         |
| 유효 시간 관리 | 검증 코드는 발급 시점으로부터 **5분**이 지나면 만료되어야 하며, 만료된 코드는 무조건 실패 처리합니다.                                                    |
| 응답 시간    | 검증 요청에 대한 응답은 평균적으로 **2초 이내**에 처리되어야 합니다.                                                                       |
| 데이터 일관성  | 저장소(Redis 등)에서 검증 코드 조회 → 검증 성공/실패 → 코드 삭제가 **원자적(atomic)** 으로 수행되어야 합니다.                                       |
| 로그 정책    | - 검증 요청의 성공/실패 여부만 로깅합니다.<br>- 실제 `code` 값이나 이메일 전체를 로그에 포함하지 않습니다.                                             |
| 확장성      | 이메일 외에도 SMS, 푸시 알림 등 다양한 인증 수단을 적용할 수 있도록 검증 로직은 인터페이스 기반으로 설계합니다.                                              |
| 가용성      | 검증 코드가 저장된 저장소(예: Redis)에 장애가 발생한 경우, 백업 저장소를 통해 복구 가능해야 합니다                                                    |
| 트랜잭션 처리  | 검증 성공 시, 코드 삭제 및 인증 상태 갱신이 모두 성공해야 트랜잭션이 커밋됩니다.                                                                 |

### 예외 처리

| 상황                    | 설명                               | 처리 로직                          |
| --------------------- | -------------------------------- | ------------------------------ |
| 이메일 형식 오류             | 이메일이 정규식에 맞지 않거나 유효하지 않은 형식      | `400 Bad Request` 응답           |
| 검증 코드 형식 오류           | 검증 코드가 6자리 숫자 형식을 만족하지 않음        | `400 Bad Request` 응답           |
| 검증 코드 누락              | 요청 본문에 `code` 필드가 누락됨            | `400 Bad Request` 응답           |
| 이메일 누락                | 요청 본문에 `email` 필드가 누락됨           | `400 Bad Request` 응답           |
| 검증 코드 불일치             | 서버에 저장된 코드와 사용자가 제출한 코드가 일치하지 않음 | `400 Bad Request` 응답           |
| 검증 코드 만료              | 코드의 유효 시간이 경과되어 만료된 상태           | `400 Bad Request` 응답           |
| 검증 코드 미발급             | 해당 이메일에 대해 발급된 코드가 존재하지 않음       | `400 Bad Request` 응답           |
| 요청 과다 (Rate Limit 초과) | 동일 이메일로 너무 잦은 검증 요청 발생           | `429 Too Many Requests` 응답     |
| 내부 서버 오류              | 저장소 장애, 트랜잭션 실패, 기타 예외           | `500 Internal Server Error` 응답 |
|                       |                                  |                                |

---


## 일반 회원가입
### 기능 개요
- 사용자는 회원가입 정보를 입력하여 회원가입을 수행합니다.
- 시스템은 사용자로부터 회원가입 정보를 입력받고 회원 정보를 생성하고 저장합니다.
- 클라이언트는 프로필 사진을 전달하기 위해서 다음과 같이 수행합니다.
	- 클라이언트는 기본 프로필 사진으로 설정하기 위해서는 profileImageFile 프로퍼티를 포함하지 않습니다.
	- 클라이언트는 새로운 프로필 사진으로 설정하기 위해서는 profileImageFile 프로퍼티에 새로운 프로필 사진을 업로드하여 전송합니다.

### 기능적 요구사항
입력 형식

| 항목                         | 필수 여부 | 설명       |
| -------------------------- | ----- | -------- |
| profileImageFile           | 선택    | 프로필 사진   |
| signupData                 | 필수    | 회원가입 데이터 |
| signupData.nickname        | 필수    | 닉네임      |
| signupData.email           | 필수    | 이메일      |
| signupData.password        | 필수    | 비밀번호     |
| signupData.passwordConfirm | 필수    | 비밀번호 확인  |

비밀번호 입력 규칙
- 길이: 8자 이상 16자 이하
- 영문자(대/소문자) 최소 1개 포함
- 숫자 최소 1개 포함
- 특수문자(!@#$%^&*) 최소 1개 포함
- 공백, 이모지, 허용되지 않은 문자는 포함 불가
- `^(?=.*[a-zA-Z])(?=.*\\d)(?=.*[!@#$%^&*])[a-zA-Z\\d!@#$%^&*]{8,16}$`

수행과정
1. 사용자는 닉네임, 이메일, 비밀번호, 비밀번호 확인, 프로필 사진(선택)을 입력하여 일반 회원가입을 요청합니다.
2. 시스템은 사용자로부터 입력 정보를 받으면 회원을 생성해도 되는지 검증합니다.
3. 검증에 성공하면 시스템은 회원 데이터를 생성하여 추가합니다.

### 비기능적 요구사항

| 구분         | 내용                                                                                                      |
| ---------- | ------------------------------------------------------------------------------------------------------- |
| 닉네임 유일성    | - 사용자의 닉네임은 시스템 내에서 고유해야 합니다.<br>- 데이터베이스의 nickname 컬럼에 `UNIQUE` 제약조건을 설정해야 합니다.                        |
| 이메일 유일성    | - 사용자의 이메일은 로컬 회원간에 고유해야 하며, 소셜 인증 플랫폼 사용자와는 구분되어야 합니다.<br>- 데이터베이스의 email 컬럼에 `UNIQUE` 제약조건을 설정해야 합니다. |
| 비밀번호 암호화   | 비밀번호는 평문으로 저장되지 않고 암호화하여 저장해야 합니다.                                                                      |
| 프로필 사진 처리  | - 프로필 사진은 선택사항이며 최대 10MB 이하여야 합니다.                                                                      |
| 성능 및 응답 시간 | - 회원가입 처리 응답시간은 평균 2초 이내를 목표합니다.<br>- 대량 회원가입 시에도 DB 트랜잭션이 안정적으로 처리되어야 합니다.                             |
| 트랜잭션 일관성   | - 회원 생성과 프로필 사진 업로드는 트랜잭션으로 처리되어야 하며, 어느 한 과정이라도 실패 시 전체 롤백합니다.                                         |
| 확장성        | - 추후 소셜 로그인 가입과 통합 가능한 구조로 설계합니다.                                                                       |


---

## 프로필 조회
### 기능 개요
- 사용자는 회원 프로필 정보를 요청합니다.
- 시스템은 사용자의 프로필 정보를 조회하여 응답합니다.

### 기능적 요구사항
처리 흐름
1. 사용자는 서버에 현재 로그인한 회원의 프로필 정보 조회를 요청합니다.
2. 서버는 회원의 식별자를 가지고 회원의 프로필 정보를 조회 및 응답합니다.

### 비기능적 요구사항

| 구분      | 내용                                                                         |
| ------- | -------------------------------------------------------------------------- |
| 응답 시간   | 프로필 조회 요청의 평균 응답 시간은 **1초 이내**를 목표로 합니다.                                   |
| 보안      | - 인증된 사용자 본인만 프로필 정보에 접근할 수 있습니다.<br>- 불필요한 개인 정보는 포함(비밀번호, 인증 토큰)하지 않습니다. |
| 데이터 정확성 | - 항상 최신 프로필 정보를 조회해야 하며, DB 캐시 사용 시 최신 상태를 반영하도록 설계합니다.                    |
| 가용성     | - 프로필 조회 API는 서비스 장애 시에도 읽기 전용으로 최대한 서비스 가능하도록 설계합니다.                      |

### 예외 처리

| 상황       | 설명                          | 처리 방식                          |
| -------- | --------------------------- | ------------------------------ |
| 미인증 접근   | 사용자가 로그인하지 않은 상태에서 요청      | `401 Unauthorized` 응답          |
| 회원 정보 없음 | 요청한 회원 ID에 해당하는 정보가 존재하지 않음 | `404 Not Found` 응답             |
| 서버 오류    | DB 조회 실패, 캐시 오류 등           | `500 Internal Server Error` 응답 |

---

## 회원 프로필 수정
### 기능 개요
- 사용자는 **회원 정보**(닉네임, 프로필 사진)을 수정할 수 있습니다.
- 클라이언트는 **form-data 형식**으로 프로필 파일(profileImageFile)과 프로필 정보(profileInformation)를 전달합니다.
	- `profileImageFile`과 `profileInformation`은 선택적으로 포함될 수 있습니다.
	- `profileInformation`에는 `nickname`이 포함됩니다.
- 클라이언트가 프로필 파일을 전송하는 경우들은 다음과 같습니다.
	- [[#프로필 수정시 기본 프로필 파일로 변경]]
	- [[#프로필 수정시 새로운 프로필 파일로 변경]]
	- [[#프로필 수정시 기존 프로필 사진으로 유지]]


### 기능적 요구사항
입력 형식

| 항목                          | 필수 여부 | 설명                                |
| --------------------------- | ----- | --------------------------------- |
| profileImageFile            | 선택    | 업로드할 새 프로필 이미지 파일(또는 비어있거나 생략 가능) |
| profileInformation          | 선택    | 회원 프로필 관련 정보 객체                   |
| profileInformation.nickname | 선택    | 수정할 닉네임                           |

처리 흐름
1. 사용자가 프로필 수정 화면에서 닉네임과 프로필 사진을 변경 후 수정을 요청합니다.
2. 서버는 요청 데이터를 검증합니다.
3. 수정 가능한 경우, 프로필 정보를 변경합니다.
4. 서버는 수정 결과를 클라이언트에 응답합니다.

동작 시나리오
(1) 기본 프로필 파일로 변경

| 구분    | 내용                                                                                          |
| ----- | ------------------------------------------------------------------------------------------- |
| 입력 조건 | `profileImageFile`이 빈 파일로 전송됨                                                               |
| 처리 로직 | - 기존 `profileUrl` 이 null 값이 아니라면 저장소에서 기존 이미지 파일을 삭제함<br>- 회원의 `profileUrl` 값을 null 값으로 저장함 |
| 결과    | 기본 이미지 프로필 사진으로 변경됨                                                                         |

(2) 새로운 프로필 파일로 변경

| 구분    | 내용                                                                                 |
| ----- | ---------------------------------------------------------------------------------- |
| 입력 조건 | `profileImageFile`에 새로운 이미지 파일이 포함됨                                                |
| 처리 로직 | - 기존 저장소에 프로필 이미지 파일이 삭제됨<br>- 새로운 이미지 파일을 저장소에 업로드<br>- `profileUrl`을 새 URL로 업데이트 |
| 결과    | 새로운 프로필 이미지 사진으로 변경됨                                                               |

(3) 기존 프로필 사진 유지

| 구분    | 내용                                                       |
| ----- | -------------------------------------------------------- |
| 입력 조건 | 요청에 `profileImageFile` 프로퍼티가 존재하지 않음                     |
| 처리 로직 | - 서버는 `profileImageFile`프로퍼티가 존재하지 않기 때문에 아무 작업도 수행하지 않음 |
| 결과    | 기존 프로필 이미지 사진 유지                                         |

### 비기능적 요구사항

| 항목       | 설명                                      |
| -------- | --------------------------------------- |
| 파일 크기 제한 | 업로드 가능한 프로필 이미지 사진의 크기는 최대 10MB 이하여야 함 |
| 데이터 유효성  | 회원의 닉네임은 중복될 수 없음 (단, 본인 닉네임은 예외)       |
| 저장소      | 프로필 이미지는 외부 저장소에 저장 및 삭제되어야 함           |
| 응답 형식    | 서버는 수정 결과를 JSON 형식으로 응답한다               |
| 보안       | 수정 요청은 인증된 본인만 수행할 수 있음                 |

### 예외 처리

| 상황                  | 처리 방식                 |
| ------------------- | --------------------- |
| 다른 회원의 닉네임과 중복되는 경우 | `409 Conflict` 응답     |
| 프로필 파일 크기 초과        | `400 Bad Request` 응답  |
| 인증되지 않은 사용자         | `401 Unauthorized` 응답 |

### 관련 문서 링크
- [닉네임 입력 규칙](#닉네임%20중복%20검사#입력%20규칙) 


---

## 회원 비밀번호 변경
### 기능 개요
- 사용자는 기존 비밀번호를 변경합니다.
- 사용자는 서버에 현재 비밀번호(currentPassword), 새로운 비밀번호(newPassword), 새로운 비밀번호 확인(newPasswordConfirm)을 전달하며 비밀번호 변경을 요청합니다.
- 서버는 입력값을 검증하고 비밀번호를 변경합니다.

### 기능적 요구사항
입력 형식

| 항목                 | 필수 여부 | 설명               |
| ------------------ | ----- | ---------------- |
| currentPassword    | 필수    | 사용자의 현재 비밀번호     |
| newPassword        | 필수    | 사용자의 새로운 비밀번호    |
| newPasswordConfirm | 필수    | 사용자의 새로운 비밀번호 확인 |

처리 흐름
1. 사용자가 비밀번호 변경 화면에서 현재 비밀번호, 새로운 비밀번호, 새로운 비밀번호 확인을 입력하고 제출합니다.
2. 서버는 사용자가 제출한 입력 정보에 대한 유효성을 검증합니다.
3. 서버는 회원의 현재 비밀번호가 사용자가 제출한 현재 비밀번호와 일치하는지 검증합니다.
4. 서버는 사용자가 제출한 새로운 비밀번호와 새로운 비밀번호가 일치하는지 검증합니다.
5. 서버는 새로운 비밀번호로 변경합니다.
6. 서버는 사용자에게 비밀번호 변경에 성공했다고 응답합니다.

### 비기능적 요구사항

| 항목                                   | 설명                                                                                                                           |
| ------------------------------------ | ---------------------------------------------------------------------------------------------------------------------------- |
| 보안성 (Security)                       | - 비밀번호는 평문으로 저장되어서는 안되며, 반드시 **단방향 암호화(BCrypt, Argon2 등)** 되어야 함<br>- 암호화 이전의 비밀번호(rawPassword)는 메모리 상에서도 오래 유지되지 않도록 관리해야 함 |
| 정책 준수 (Password Policy)              | - [비밀번호 입력 규칙](#일반%20회원가입#비밀번호%20입력%20규칙)                                                                                    |
| 응답 보안 (Response Security)           | - 비밀번호 변경 결과를 응답할때 비밀번호 자체를 포함해서는 안됨<br>- 로그나 예외 메시지에도 비밀번호가 포함되지 않도록 해야 됨                                                   |
| 트랜잭션 일관성 (Transactional Consistency) | - 비밀번호 변경 중 예외 발생 시, 데이터는 롤백되어야 함                                                                                            |
| 감사/로그 (Auditing & Logging)           | - "비밀번호 변경 성공/실패" 이벤트만 로깅하고, 입력된 비밀번호는 절대 로그에 남기지 않아야함                                                                       |
| 사용자 경험 (UX)                          | - 비밀번호 정책 위반 시 사용자에게 명확한 사유를 반환해야 함. (예: “특수문자가 포함되어야 합니다.”)                                                                 |
| 동시성(Concurrency)                     | - 사용자가 여러 기기에서 동시에 비밀번호 변경시, 가장 최근 요청만 유효하도록 처리함                                                                             |
| 인증 세션 처리                             | - 비밀번호 변경 이후 기존 액세스 토큰 또는 세션은 모두 무효화해야함. (즉, 로그아웃 처리)                                                                        |

### 예외 처리
| 상황                                | 처리 방식                |
| --------------------------------- | -------------------- |
| 비밀번호 유효성 검증 실패하는 경우              | `400 Bad Request` 응답 |
| 현재 비밀번호가 일치하지 않는 경우               | `400 Bad Request` 응답 |
| 새로운 비밀번호와 새로운 비밀번호 확인이 일치하지 않는 경우 | `400 Bad Request` 응답 |

### TODO
- 예외 발생시 암호화 이전의 비밀번호가 로깅되지 않도록 함
- 비밀번호 변경 실패시 사용자에게 명확한 사유를 반환해야함(예: "특수문자가 포함되어야 합니다.")
- 동시성 비기능적 요구사항 만족
- 비밀번호 변경 이후 액세스 토큰 무효화 처리

---

## 계정 삭제
### 기능 개요
- 사용자의 계정을 삭제합니다.
- 서버는 회원과 관련된 정보를 삭제한후 마지막으로 회원 정보를 삭제합니다.
- 서버는 로그아웃 처리합니다.

### 기능적 요구사항
입력 형식

| 항목           | 필수 여부 | 설명                |
| ------------ | ----- | ----------------- |
| refreshToken | 선택    | 인증된 사용자의 리프레시 토큰 |
처리 흐름
1. 사용자는 서버에 계정 삭제를 요청합니다.
2. 서버는 회원과 관련된 데이터를 삭제하고 마지막으로 회원 정보를 삭제합니다.
3. 서버는 현재 인증된 사용자의 로그아웃 처리합니다.
4. 서버는 사용자에게 계정 삭제 성공을 응답합니다.

### 비기능적 요구사항

| 항목                        | 설명                                                                                                                |
| ------------------------- | ----------------------------------------------------------------------------------------------------------------- |
| 보안(Security)              | 계정 삭제 요청은 반드시 인증된 사용자만 수행할 수 있어야 합니다.<br>- Access Token 또는 Refresh Token 검증을 통과해야함<br>- CSRF, Replay Attack 방지 필요 |
| 데이터 일관성(Data Consistency) | - 계정과 연관된 모든 데이터(포트폴리오, 매입 이력 등)는 트랜잭션 단위로 일관되게 삭제되어야 함<br>- 일부 데이터만 삭제되는 불일치 상태가 되어서는 안됨                         |
| 로그(Log Management)        | - 삭제 요청 및 처리 결과는 **보안 로그**로 기록되어야 합니다.  <br>- 예: 삭제 요청자 ID, 요청 시각, 처리 상태, 요청 IP 등                                 |
| 성능(Performance)           | - 계정 삭제 요청은 2초 이내에 완료되어야 합니다.  <br>- 단, 백그라운드 비동기 삭제 프로세스를 사용하는 경우 사용자에게 즉시 완료 응답 후 비동기 처리가 가능                    |
| 가용성(Availability)         | 계정 삭제 시 시스템의 다른 기능(로그인, 회원가입 등)에 영향을 주지 않아야 합니다.                                                                  |
| 안정성(Reliability)          | 삭제 도중 장애가 발생한 경우, 트랜잭션 롤백을 통해 데이터가 원복되어야 합니다.                                                                     |


### 예외 처리

| 상황           | 설명                                     | 처리 방식                                   |
| ------------ | -------------------------------------- | --------------------------------------- |
| 인증되지 않은 요청   | Access Token 또는 Refresh Token이 유효하지 않음 | `401 Authorized` 응답                     |
| 존재하지 않는 사용자  | 이미 탈퇴했거나 존재하지 않는 계정으로 요청함              | `404 Not Found` 응답                      |
| 관련 데이터 삭제 실패 | 일부 연관 데이터 삭제 실패                        | `500 Internal Server Error` 응답, 트랜잭션 롤백 |
| 토큰 무효화 실패    | 로그아웃 처리 중 Redis 또는 인증 서버 오류 발생         | 로그아웃 실패를 로깅 처리하고 `200 OK` 응답            |

---

## 인증
### 일반 로그인
- 사용자는 이메일과 비밀번호를 입력하여 일반 로그인을 할 수 있습니다.
- 서버는 로그인 후 쿠키에 액세스 토큰 및 리프레시 토큰을 넣어서 응답

### 소셜 로그인
- 사용자는 구글, 카카오, 네이버중 한곳을 선택하여 소셜 로그인을 할 수 있습니다.
- 만약 사용자가 첫 소셜 로그인을 하는 경우라면 회원가입 처리되어야 합니다.

### 로그아웃
- 사용자는 로그아웃을 요청할 수 있습니다.
- 쿠키로 액세스 토큰, 리프레시 토큰을 전달받아서 로그아웃 처리합니다.
- 서버는 액세스 토큰, 리프레시 토큰을 받으면 블랙 리스트에 추가하여야 합니다.

### 액세스 토큰 갱신
- 사용자는 인가가 요구되는 API 요청시 쿠키에 액세스 토큰 및 리프레시 토큰을 담아서 전송한다. 만약 액세스 토큰이 만료되고, 리프레시 토큰이 만료되지 않았다면 액세스 토큰을 갱신한다. 갱신한후 서버는 쿠키에 액세스 토큰, 리프레시 토큰을 담아서 응답한다
- 리프레시 토큰의 만료시간이 1시간 미만인 경우 리프레시 토큰 또한 갱신하여야 한다
- 사용자가 API 요청시 액세스 토큰, 리프레시 토큰 둘다 만료되었다면 401 응답합니다.
- 해당 서비스는 별도의 액세스 토큰 갱신 API를 명시하여 처리하는 것이 아닌 다른 인가가 요구되는 API 수행중에 처리하여야 합니다.

## 알림

### 회원 알림 목록 조회
- 사용자는 웹 애플리케이션을 실행하면서 그동안 온 알림들을 조회합니다.
- **알림 조회시 읽지 않은 알림들과 읽었지만 삭제하지 않은 알림들을 조회**합니다.
- 정렬 기준 : 최근에 온 알림 메시지가 제일 앞에 위치해야 함

### 회원 알림 모두 읽음
- 사용자는 알림 메시지들을 모두 읽을 수 있습니다.
- 클라이언트는 알람 모두 읽음 처리를 위해서 서버로 알림의 등록번호 리스트를 전달하며 읽음 처리를 요청합니다.
- 서버는 알림 등록번호 리스트를 받아서 해당하는 알림들을 읽음 처리합니다.

### 회원 특정 알림 읽음
- 사용자는 특정한 알림을 읽을 수 있습니다.
- 클라이언트는 알림 읽음 처리를 위해서 서버로 알림의 등록번호를 전달하며 읽음 처리를 요청합니다.
- 서버는 알림 등록번호를 받아서 해당하는 알림을 읽음 처리합니다.

### 회원 알림 단일 삭제
- 사용자는 특정한 알림을 선택하고 지우기를 할 수 있습니다.

### 회원 알림 전체 삭제
- 사용자는 알림 메시지들을 모두 지울 수 있습니다.

### 회원 알림 설정 수정
사용자는 클라이언트 애플리케이션의 데스크탑 설정 및 사용자 알림 설정을 수정할 수 있습니다.
- 브라우저로부터 데스크탑 알림 받기는 사용자가 애플리케이션으로부터 브라우저 알림을 받을 것인지 설정하는 옵션입니다.
	- 기본값 : false
- 포트폴리오 목표 수익률 도달 알림 설정은 사용자가 애플리케이션으로부터 각각의 포트폴리오에 설정된 목표 수익률 도달 알림을 받을 것인지 설정하는 옵션입니다.
	- 기본값 : true
	- 해당 옵션이 false이면 각 포트폴리오의 목표 수익률 도달 알림이 true여도 알림을 받지 않습니다. 즉, 전체 포트폴리오의 목표 수익률 도달 알림을 받지 않겠다는 것을 의미합니다.
- 포트폴리오 최대 손실율 도달 알림 설정은 사용자가 애플리케이션으로부터 각각의 포트폴리오에 설정된 최대 손실율 도달 알림을 받을 것인지 설정하는 옵션입니다.
	- 기본값 : true
	- 해당 옵션도 false이면 목표 수익율 도달 알림 설정과 동일합니다.
- 종목 지정가 알림 설정은 사용자가 애플리케이션으로부터 특정한 종목이 특정한 가격에 도달했음을 알려주는 설정입니다.
	- 기본값 : true
	- 해당 옵션이 false이면 특정한 종목 지정가 알림이 활성화되어 있어도 전부 알림을 받지 않습니다.
- 해당 알림 설정이 false로 변경되어도 각 포트폴리오 및 지정가에 설정된 상세 알림 설정은 변경되지 않는다. 예를 들어 포트폴리오의 목표 수익률 도달 알림 설정이 false로 변경되어도 각 특정한 포트폴리오에 설정된 목표 수익율 도달 알림은 false로 변경되지 않는다.
![[Pasted image 20240131153924.png]]
- 알림 설정에서 4가지 설정(브라우저, 포트폴리오 목표 수익률, 최대 손실율, 종목 지정가 알림)이 전부 비활성화로 변경한 다음에 저장을 한다면 서버의 FCM 토큰은 제거되어야 합니다.
	- 별도의 fcmTokenId가 전송됩니다.