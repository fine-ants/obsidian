## 성능 테스트 시나리오: 비동기 갱신 최적화 검증

### 1. 테스트 환경 및 조건

- **대상 장비:** Mac os (8 vCPU, 16GB RAM)
- **가상 사용자 (VU):** 100명 (동시 접속자)
- 램프업 : 50초
	- (50초 동안 1초에 2명씩 천천히 접속)
- **테스트 지속 시간:** 10분
- **데이터 셋업:** * Redis에 총 **50개 종목**의 시세 데이터 미리 적재.
    - 모든 데이터의 타임스탬프를 **현재 시간 기준 -10분**으로 설정 (신선도 5초 초과 → Stale 상태 강제).
- **시간 설정:** 서버 로직 상 **'장시간 외(Closed Market)'**로 판정되는 시간대 설정.
    
---

### 2. 시나리오 상세 루프 (User Flow)
각 가상 사용자는 아래 동작을 반복합니다.
1. **로그인:** 테스트 회원 계정으로 인증 (JWT 등 발급).
2. **종목 조회:** 준비된 50개 종목 리스트 중 하나의 종목을 선택하여 종목 상세 정보 조회 API 호출.
3. **대기 (Think Time):** 5~6초 대기 후 다시 다른 종목 조회 반복.
    
---

### 3. 대조군 vs 실험군 설정

#### **[Scenario A] 기존 시스템 (개선 전)**
- **기대 동작:** 1. 유저가 시세를 요청하면 Redis에서 Stale 데이터를 꺼내 반환함. 2. 동시에 **비동기 이벤트가 발행**되어 외부 KIS API 호출 스레드가 생성됨.
- **예상 병목:** 100명이 계속 요청할 경우 초당 수십 개의 비동기 스레드가 생성되어 CPU 점유율이 급증하고 외부 API와의 통신이 증가함

#### **[Scenario B] 개선 시스템 (개선 후)**
- **기대 동작:** 1. 유저가 시세를 요청하면 Redis에서 Stale 데이터를 꺼내 반환함. 2. **장시간 외임을 판별하여 이벤트를 발행하지 않음.** (핵심 차단 로직)
- **예상 결과:** 비동기 스레드 생성이 0에 수렴하며, 단순 조회만 수행하므로 CPU 및 메모리 사용량이 매우 낮고 안정적으로 유지됨.


### 4. 수집 및 비교 지표 (Key Results)
| **비교 항목**             | **측정 도구** | **목적**                         |
| --------------------- | --------- | ------------------------------ |
| **P95 응답 속도**         | JMeter    | 부하 시 응답의 최대 지연 시간 확인           |
| **CPU Usage (%)**     | VisualVM  | 불필요한 스레드 생성에 따른 연산 부하 비교       |
| Throughput            | Jmeter    | 서버가 초당 처리하는 요청 수를 측정하여 효율성을 증명 |
| **External API Call** | App Log   | 실제 외부 통신이 차단되었는지(0건) 최종 확인     |

## 성능 테스트 결과

### 시나리오 A
![](refImg/Pasted%20image%2020260214122838.png)
![](refImg/Pasted%20image%2020260214122828.png)
![](refImg/Pasted%20image%2020260214122814.png) 
![](refImg/Pasted%20image%2020260214122800.png)

스레드
- lettuce-nioEventLoop : Redis와 통신하는 스레드
- event-async-executor : 비동기 이벤트를 다루는 스레드
- reactor-http-nio : WebClient를 이용하여 외부 통신을 다루는 스레드
- scheduler-async-executor : 스케줄러 실행시 담당하는 스레드
![](refImg/Pasted%20image%2020260214123150.png)
![](refImg/Pasted%20image%2020260214123209.png)
![](refImg/Pasted%20image%2020260214123135.png)
Running 순으로 정렬한 것중에서 일부
![](refImg/Pasted%20image%2020260214123320.png)

### 시나리오 B
![](refImg/Pasted%20image%2020260214125047.png)
![](refImg/Pasted%20image%2020260214125037.png)
![](refImg/Pasted%20image%2020260214125019.png)

![](refImg/Pasted%20image%2020260214125009.png)

![](refImg/Pasted%20image%2020260214125120.png)
![](refImg/Pasted%20image%2020260214125131.png)
![](refImg/Pasted%20image%2020260214125143.png)
![](refImg/Pasted%20image%2020260214125213.png)

### 성능 테스트 비교 결과
- 평균 응답시간, 처리량면에서는 두 시나리오 모두 큰 차이는 없음
- 시나리오 A는 비동기 이벤트를 이용한 외부 API 호출이 있었던 반면에 시나리오 B는 외부 API 호출이 없었음
- 시나리오 A 같은 경우에는 비동기 이벤트 처리개수가 4472개인 반면에 시나리오 B 같은 경우에는 11개밖에 없었습니다.
- 

