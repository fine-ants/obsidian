OAuth2의 컨텍스트에서 CSRF에 대해서 살펴보며, 발생 가능한 공격과 OAuth2가 웹 리소스를 보호하는데 사용될 때 어떻게 대응하는지 방법을 살펴봅니다.

OAuth2는 클라이언트 애플리케이션이 사용자를 대신하여 리소스를 가져오도록 해주는 프로토콜입니다. 단, 조건은 사용자가 클라이언트 애플리케이션에 리소스를 가져올 수 있도록 승인을 해주어야 합니다. 클라이언트가 허용되는 작업들은 Resource Server에서 수행됩니다. 그리고 사용자들은 클라이언트 애플리케이션이 승인된 것에 한하여 작업을 할 수 있도록 Authorization Server에 말해 놓습니다. 대표적인 Authorization Server들은 페이스븍과 구글이 존재하며 둘 모두 Resource Server 또한 제공하고 있습니다.

Cross Site Request Forgery(CSRF) 공격은 목표로 하는 클라이언트 애플리케이션에 몇몇 상태를 변경하는 링크를 사용자가 클릭하게 하여 상태를 변경하게 하는 공격입니다. 만약 사용자가 이미 클라이언트 애플리케이션에 로그인 되어 있다면, 브라우저가 인증 헤더나 쿠키를 자동으로 전송하므로 공격을 인식하지 못할 수도 있습니다. 

OAuth2 시스템은 CSRF 공격에 취약합니다. CSRF 공격에 당한 사용자는 로그인을 수행하여 인증하고 사용자의 상태가 변경될 수 있습니다. OAuth2 프로토콜의 특정한 공격에 집중합니다. 이러한 맥락에서 해커는 사용자가 할 수 있는 모든 것(토큰 범위 내에서)을 수행할 수 있는 액세스 토큰을 얻으려고 할 것에 집중할 것입니다.

아래에서 논의하는 CSRF에 대한 방어책 중 일부는 OAuth2 클라이언트 애플리케이션의 구현에서 비롯되기 때문에 Authorization Server가 OAuth2 스펙을 구현하는 한 모든 클라이언트 애플리케이션에서 사용할 수 있습니다. 방어책 중 일부는 OAuth2 Authorization Server 자체에 구현되어 있기 때문에 서버 컴포넌트들의 일부만 개발자가 구현하면 됩니다. 일부는 스펙에 의해서 의무하되거나 강력하게 제안되며, 일부는 프로토콜을 신중하게 사용하는데서 비롯됩니다. 

몇몇 CSRF 시도 예제들은 아래 내부 링크로서 주어집니다. 해당 링크는 클릭했다고 위허함지 않습니다. 해당 예제들은 데모이고 손상될 수 있는 데이터나 신원을 밝힐수 없는 데이터는 없습니다. 여러분들은 로그인 화면 (marissa/koala)에서 인증정보를 입력하여 Authroziation Server로 로깅할 수 있습니다. 공격들은 무조건 성공합니다. 왜냐하면 데모 시스템이 취약하게 구현되어 있기 때문입니다. 여러분들이 실제 OAuth2 구현하는 사람이라면 더욱 주의하시기를 바랍니다.

### Attacks on the Authorization Server
사용자가 이미 인증하여 로그인한 시점에서 사용자가 Authorization Server에 대한 링크를 클릭하도록 사용자를 속여서 Access Token을 얻으려고 합니다. 예제들은 Authorization Server가 사용자가 요청하는 URI로 Redirect 할 수 있다는 사실에 따라 달라집니다. 특정 Redirect URI가 해당 클라이언트 애플리케이션에 등록되지 않았음에도 불구하고 스펙에서 허용합니다. 실제로 페이스북은 리다이렉트 URL을 사전 등록된 애플리케이션(즉, 동일한 호스트, 경로 등으로 시작)에 의해 "소유"되도록 제한합니다. 이는 꽤 정상적이지만 스펙의 일부는 아닙니다.

공격을 시도하려면 Authorization Server가 필요하고 여러분들은 그저 링크를 클릭하고 시크릿 정보들이 Redirect에서 어떤것이 드러나는지 확인할 수 있습니다. 


- [Cross Site Request Forgery and OAuth2](https://spring.io/blog/2011/11/30/cross-site-request-forgery-and-oauth2)

