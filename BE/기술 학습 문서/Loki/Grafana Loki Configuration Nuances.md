
## The task of collecting logs
어떤 로깅 시스템을 통합하기 위해 시도하기 전에 여러분들 스스로 다음 4가지 질문에 답해보세요.
1. 나는 지금 어떻게 로그를 모으고 있나요?
2. 추후에 로그들을 쉽게 처리하기 위해서 로그들에서 올바른 메타데이터를 어떻게 추출하는가?
3. 나는 로그 데이터를 빠르게 저장하고 탐색할 수 있도록 어떻게 데이터를 저장하는가?
4. 나는 어떻게 로그를 쿼리하는가?

모든 시스템, 예를 들어 syslog, Elasticsearch, ClickHouse 기반 시스템, 심지어 Grafana Loki 자체도 이 질문들에 대해서는 서로 다르게 응답할 것입니다.

그래서 우리가 아키텍처에 대해서 의논할때, Grafana Loki가 Elasticsearch와 개념적으로 어떻게 다른지, 그리고 로그 저장비용 측면에서 Loki가 왜 좋은지 이야기 할것입니다.

로그 컬렉션 파이프라인은 일반적으로 다음과 같이 간단하고 직관적입니다.
![[Pasted image 20250210152916.png]]

우리는 다양한 데이터 소스들에서 로그들을 얻습니다. 대표적으로 쿠버네티스 클러스터, 가상 머신, 도커 컨테이너 등이 있습니다. 이 데이터 소스들은 로그들을 수집하고, 처리하고 단계를 필터링을 수행합니다.
그리고 나서 데이터 소스들은 여러분들이 지정한 저장소에 데이터들을 저장합니다. 예를 들어 ClickHouse, S3, Grafana Loki와 같은 저장소가 있습니다. 하지만 데이터를 서로 다른 쪽에서 가져오는 모든 사용자가 각기 다른 액션 스크립트를 가질수 있다는 점을 유의해야 합니다.  예를 들어 1년 이나 10분 이내의 데이터를 가져올수 있습니다.

## Ways to launch Loki
Loki를 실행하는 3가지 방법이 있습니다. 이 방법들에는 대체로 규모에서 차이가 있습니다.

### Single-binary
![[Pasted image 20250210153716.png]]

이 방법은 주요한 로키 튜토리얼에서 가장 많이 사용하는 방법입니다. 로직은 다음과 같습니다. 우리는 스토리지와 연결합니다.

스토리지의 역할은 파일 시스템과 S3 버킷 모두에서 수행됩니다. 하지만 여기서는 중요치 않습니다. 이 접근은 장점들을 가지고 있습니다. 예를 들어 런칭이 쉽습니다. 여러분들은 최소한의 설정만 하면 됩니다. 단점은 낮은 **내결함성**입니다. 만약 머신에 장애가 발생하면 로그가 기록되지 않습니다.

위와 같은 상황은 다음과 같이 개선할 수 있습니다.
- 서로 다른 2개의 가상 머신에서 같은 설정을 가진 로키 프로세스를 실행시킵니다.
- memberlist 영역을 사용하여 클러스터로 결합시킵니다.
- 스토리지 전면에 Nginx나 HAProxy와 같은 프록시 서버를 둡니다.
- 가장 중요한 것은 모든것을 하나의 스토리지에 연결하는 것입니다.

여러분들은 프로세스를 추후에 3,4,5개의 노드로 증가시킬 수있습니다.  결과적으로 다음과 같은 결과를 얻을 수 있습니다.
![[Pasted image 20250210154851.png]]

로키 같은 경우에는 쓰기와 읽기 둘다 처리합니다. 따라서 읽기 및 쓰기 처리 요청에 대한 부하가 모든 로키 인스턴스들에 고르게 분배됩니다. 그러나 실제는 고르게 분배되지 않습니다. 왜냐하면 때로는 읽기가 많고, 다른 때는 쓰기가 많기 때문입니다. 

## SSD: Simple Scalable Deployment
두번째 방법은 첫번째 방법을 따르면서 읽기와 쓰기 처리하는 로키 프로세스를 분리하는 것입니다. 예를 들어 디스크에 의존적인 프로세스는 하나의 하드웨어에서 실행하고, 덜 의존적인 프로세스는 다른 하드웨어에서 실행할 수 있습니다. 

여러분들이 로키를 실행할때 -target=write 또는 -target=read 옵션을 전달합니다. 그러면 로키 프로세스들은 특정 쿼리 경로에 책임이 있는 엔티티들을 실행합니다. 간단하게 여러분들은 앞에 프록시 서버가 필요합니다. 프록시 서버가 쓰기 쿼리이면 write 노드에게 서빙하고 읽기 쿼리이면 read 노드에게 서빙합니다.
![[Pasted image 20250210155831.png]]

Grafana는 이를 가장 권장하는 방식으로 간주하고 이를 적극적으로 개발하고 있습니다.

## Microservices mode
마이크로서비스 모드는 우리가 독립적인 각각의 로키 컴포넌트를 실행할 때 사용할 수 있는 방법입니다. 

구성 요소가 많지만, 이들은 쉽게 서로 분리될 수 있으며, 2개 또는 3개의 그룹으로 나눌수 있습니다.
![[Pasted image 20250210160444.png]]
1. 쓰기 컴포넌트 그룹 : Distributor, Ingester
2. 읽기 컴포넌트 그룹 : Querier, Query-frontend, Index-gateway
3. 그외 모든 유틸리티 : Caches, Compactor 등

## The arrangement of Grafana Loki architecture
조금더 아키텍처에 대해서 살펴보며, 각 영역에서 무엇이 설정되었는지 이해해봅니다.

먼저 블록 내 데이터가 어떻게 인덱싱되는지 살펴보겠습니다. Elasticsearch는 전체 텍스트에서 모든 문서들을 기본적으로 인덱싱하는 반면에 Grafana Loki는 로그의 내용을 인덱싱하지 않고 오직 시간이나 레이블과 같은 메타 데이터만 인덱싱합니다. 이 레이블은 프로메테우스 레이블과 매우 비슷합니다. 

결과적으로 Garafana에는 매우 작은 데이터가 포함되어 있기 때문에 매우 작은 데이터 인덱스를 저장하게 됩니다. 여기서 강조하고 싶은 점은 Elasticsearch의 경우 인덱스가 실ㅈ


