

## 1. Gradle Java 플러그인과 Java-Library 플러그인
### Java 플러그인은 무엇인가?
Gradle 설정에서 Java 플러그인을 추가하면 해당 프로젝트를 자바 프로젝트로 만들고 자바 소스코드를 컴파일, 테스트, 빌드하는데 필용한 기능들을 Gradle에 부여해줍니다.

```gradle
plugins {  
    id 'java'
}
```

Java 플러그인을 추가하면 다음 그림과 같은 테스크들을 사용할 수 있습니다. 각 테스크들간에 화살표 관계는 해당 테스크를 완료하기 위한 선행 조건 테스크들을 의미합니다. 예를 들어 build 테스크를 수행하기 위해서는 check, assemble 테스크가 먼저 수행 및 완료되어야 합니다.
![](refImg/Pasted%20image%2020251201155125.png)

자바 컴파일러가 자바 소스 코드(`*.java`)를 컴파일 하게 되면 바이트 코드(`*.class`)를 생성합니다. 이러한 바이트 코드들은 JVM(Java Virtual Machine)에 의해서 읽어지게 됩니다. 그리고 읽어진 바이트 코드들은 기계어로 번역됩니다. JVM이 자바 소스코드를 컴파일하거나 컴파일된 바이트코드를 읽어서 실행하기 위해서 파일과 패키지를 탐색하는데, 이러한 경로를 **클래스패스(classpath)**라고 합니다.

클래스패스에는 두가지 종류가 존재합니다. 첫번째는 컴파일 클래스 패스(compile class path), 두번째는 런타임 클래스 패스(runtime class path)입니다.
- 컴파일 클래스 패스(compile classpath) : 자바 소스 코드(`*.java`)를 바이트 코드(`*.class`)로 컴파일 할때 탐색하는 경로
- 런타임 클래스 패스(runtime classpath) : 컴파일 된 바이트 코드(`*.class`)을 JVM이 읽기 위해서 탐색하는 경로

**Gradle의 클래스패스 의존성 설정**
Gradle을 기반으로 자바 애플리케이션을 빌드하기 위해서 설정하는 의존성 설정이 존재합니다. 그래서 Gradle 설정에서 각각의 라이브러리의 의존성을 추가할때 어느 범위로 노출시킬 것인지 결정할 수 있습니다. 종류는 다음과 같습니다.
- compileOnly : 컴파일 클래스 경로에만 라이브러리를 설정함
- runtimeOnly : 런타임 클래스 경로에만 라이브러리를 설정함 
- implementation : 컴파일 클래스 경로, 런타임 클래스 경로 두곳에 라이브러리를 설정함
- api : 컴파일 클래스 경로, 런타임 클래스 경로 두곳에 라이브러리를 설정함

### Java-Library 플러그인은 무엇인가?
Java-Library 플러그인은 기본 Java 플러그인의 모든 기능을 포함하고, 라이브러리 개발에 필요한 특화된 규칙(예: 프로덕션 코드는 src/main/java에 위치)을 추가합니다.
Java 플러그인과의 차이점은 라이브러리 개발시 어떤 의존성을 라이브러리의 외부 API로 노출하고(다른 프로젝트가 접근 가능), 어떤 의존성을 내부 구현으로 숨길지(다른 프로젝트가 접근 불가)을 정의할 수 있습니다.(이때 `api`, `implementation` 설정이 사용됨)
Java-Library를 사용하면 java 플러그인이 제공하는 기본적인 디렉토리 구조, 빌드 테스크(compileJava, jar 등), 그리고 의존성 설정(testImplementation 등)을 모두 자동으로 사용할 수 있습니다.


## 2. Gradle implementation과 api의 차이
### 전이 의존성이란 무엇인가?
Gradle 설정에서 의존성 라이브러리 설정시 다양한 설정이 옵션이 존재합니다. 대표적으로 implementation과 api 의존성 설정이 존재합니다. 두 설정은 모두 컴파일 클래스경로(compile classpath)와 런타임 클래스경로(runtime classpath) 두곳 모두에 라이브러리를 설정하는 공통점을 가지고 있습니다. 하지만 대표적인 차이점은 **전의 의존성(transitive dependency)의 컴파일 경로 노출 여부**가 있습니다. 
전이 의존성은 어떤 프로젝트 A가 직접적으로 명시하지 않은 라이브러리 C인데도 불구하고, 프로젝트 A가 다른 프로젝트 B를 의존하는 것만으로도 라이브러리 C를 사용할 수 있다면 전이 의존성이 있는 것입니다.
![](refImg/Pasted%20image%2020251202115140.png)

### implementation과 api의 차이
**`api` 의존성 설정은 전이 의존성을 허용하고 있습니다.** 예를 들어 프로젝트 A,B,C가 존재하고 프로젝트 B는 프로젝트 C를 의존하고 프로젝트 A는 프로젝트 B를 의존하는 관계라고 가정합니다. 그림으로 보면 다음과 같습니다.
![](refImg/Pasted%20image%2020251202120803.png)

위 그림을 보면 프로젝트 C에는 Hello라는 클래스가 public으로 구현되어 있습니다. 그런한 프로젝트 C를 프로젝트 B는 api 설정으로 의존성 설정되어 있습니다. `api`로 설정하였기 때문에 전이 의존성을 허용합니다. 그래서 프로젝트 B를 의존하고 있는 프로젝트 A에서는 프로젝트 C에 정의되어 있는 Hello 클래스를 참조하여 객체를 생성할 수 있습니다.

반면에 `implementation` 의존성 설정은 전이 의존성을 허용하고 있지 않습니다. 예를 들어 위 그림에서 프로젝트 B가 프로젝트 C의 의존성 설정을 `api`가 아닌 `implementation`으로 설정해보겠습니다. 그렇게 되면 상황은 다음 그림과 같이 됩니다.
프로젝트 B의 의존성 라이브러리 설정에서 `implementation`으로 설정된 의존성 라이브러리들은 내부 구현으로 숨겨져 있기 때문에 프로젝트 A가 프로젝트 C의 Hello 클래스를 사용할 수 없습니다.
![](refImg/Pasted%20image%2020251202122742.png)

### implementation과 api의 사용
`api` 대신 `implementation`을 사용하는 경우 장점은 다음과 같습니다.
- 컴파일 클래스패스(compile classpath)에 `implementation`으로 설정된 의존성 라이브러리들이 노출되지 않아서 해당 라이브러리들에 대해서 종속적이지 않게 됩니다.
- 의존성 라이브러리들이 노출되지 않아서 그만큼 컴파일 속도가 빨라집니다.
- `implementation`으로 설정된 의존성 라이브러리들이 변경되면 다시 컴파일하지 않아도 되서 재컴파일 횟수가 줄어듭니다.




### implementation과 api 차이 요약
`implementation`은 전이 의존성을 허용하지 않아서 어떤 프로젝트를 의존하는 외부의 프로젝트들로부터 의존성 라이브러리들을 노출시키지 않을 수 있습니다.
반면에 `api`은 전이 의존성을 허용하기 때문에 프로젝트를 의존하는 외부의 프로젝트로부터 의존성 라이브러리를 노출시켜서 사용하게 할 수 있습니다.



