
### heap dump 파일은 무엇인가?
- 힙 메모리는 임의로 생성한 객체들이 동적으로 할당되는 공간을 의미하는데, **힙 덤프 파일은 운영중인 애플리케이션의 힙 메모리 영역을 스냅샷으로 기록한 내역을 저장한 파일을 의미**합니다.

### heap dump 파일 생성 시기
- 모든 경우에 대해서 스냅샷을 생성할 필요는 없고, 런타임 시점에 OOM(Out of Memory)이 발생하는 경우에 스냅샷을 생성하고 파일 내용을 분석하면 됩니다.

### OOM은 어떤 경우에 발생하는가?
#### OutOfMemoryError: Java Heap Space
- 힙 영역에 공간이 부족한 경우에 발생합니다. 가장 많이 확인되는 케이스일 것입니다.
- 힙 영역에 대한 공간 확보는 GC를 통해서 이루어지는데, GC를 수행하기 이전에 힙 메모리 영역이 부족할 경우에 발생합니다.

```java
public class JavaHeapSpace {
  public static void main(String[] args) throws Exception {
    String[] array = new String[100000 * 100000];
  }
}
```

#### OutOfMemoryError: GC Overhead limit exceeded
- GC를 진행하는데 CPU 98% 이상 사용되고, GC 이후에 2% 미만으로 복구 되었을 경우입니다.
- 무분별하게 객체를 생성하는 경우에 발생합니다. 문제점을 해결하고, 경우에 따라서 메모리 사이즈를 늘리는 것을 추천합니다.
```java
public class GCOverhead {
  public static void main(String[] args) throws Exception {
    Map<Long, Long> map = new HashMap<>();
    for (long i = 0l; i < Long.MAX_VALUE; i++) {
      map.put(i, i);
    }
  }
}
```

#### OutOfMemoryError: Requested array size exceeds VM limit
- 힙 영역보다 더 큰 영역의 배열을 할당할 경우 발생합니다.
- 배열 사이즈를 조정하거나 메모리 사이즈를 증가시켜서 해결할 수 있습니다.
```java
public class GCOverhead {
  public static void main(String[] args) throws Exception {
    for (int i = 0; i < 10; i++) {
      int[] arr = new int[Integer.MAX_VALUE - 1];
    }
  }
}
```

#### OutOfMemoryError: Metaspace
- Metaspace 영역이 부족한 경우에 발생합니다.
- 클래스의 메타데이터(클래스 이름, 생성 정보, 필드 정보, 메서드 정보 등)가 저장되는 공간으로 JDK 7 이전에는 PermGen으로 정의되었습니다. java8 이후부터는 메타데이터는 메타스페이스에 저장됩니다. 메타스페이스는 Native Memory(운영체제에서 제공하는 메모리 공간, 힙 영역 외부에 존재함)에 저장됩니다.
- PermGen 영역은 힙 메모리에 포함되어 적은 범위로 설정되어 있기 때문에 GC가 빈번히 발생했으며, 이를 개선하고자 메타 스페이스 영역으로 변경되었습니다.
- **메타 스페이스 영역으로 개선되면서 힙 메모리 영역을 사용하지 않고 OS에서 제공하는 native 메모리 영역을 사용하므로 GC를 수행하지 않고도 자동으로 크기를 증가시켜서 공간을 확보할 수 있게 되었습니다.**
- 그래도 자동으로 크기는 증가하는 과정보다 더 많은 메타 데이터들이 저장되면, 에러가 발생할 수 있기 때문에 `-XX:MetaspaceSize`, `-XX:MaxMetaspaceSize` 설정을 추가하여 오류를 해결할 수 있습니다. (기본값은 20MB)
	- JVM 옵션의 `-XX:~`에서 XX는 extension option의 약자입니다.


#### OutOfMemoryError: unable to create native thread
- 사용가능한 쓰레드가 존재하지 않는 경우에 발생합니다.
```java
public class ThreadsLimits {
  public static void main(String[] args) throws Exception {
    while (true) {
      new Thread(
          new Runnable() {
            @Override
            public void run() {
              try {
                Thread.sleep(1000 * 60 * 60 * 24);
              } catch (Exception ex) {}
            }
          }
      ).start();
    }
  }
}
```

### heap dump 파일 생성 방법
- 힙 덤프 파일을 생성하는 방법에는 2가지가 있습니다.
	- 실시간으로 스냅샷 생성
	- OOM(OutOfMemory)이 발생하는 시점에 자동 생성

#### OOM이 발생하는 경우에 힙 덤프 파일 자동 생성
- 애플리케이션 내부적으로 OOM이 발생하는 경우에 힙 덤프 파일을 생성할 수 있도록 옵션을 추가할 수 있습니다.
```shell
java -jar -XX:+HeapDumpOnOutOfMemoryError \\
   -XX:HeapDumpPath=/home/centos/application/dumps/ \\
   -XX:OnOutOfMemoryError="kill -9 %p" \\
   application-0.0.1-SNAPSHOT.jar
```
- XX:+HeapDownOnOutOfMemoryError: OOM이 발생하는 경우에 힙덤프 파일을 생성합니다.
- XX:HeapDumpPath: 힙덤프가 생성되는 디렉토리 경로를 지정합니다.
- XX:OnOutOfMemoryError: OOM이 발생하는 경우 수행할 스크립트를 지정합니다. (보통 OOM이 발생하면 애플리케이션이 다운되기 때문에 재시작 스크립트를 다시 수행하기도 합니다.)

#### 실시간 스냅샷 생성
- 사용자가 실시간으로 모니터링을 하다가 스냅샷을 생성할 수 있습니다.
- 스냅샷을 생성하기 위해서 실행중인 프로세스 아이디를 확인합니다.
```shell
ps -ef | grep java
``` 
![[Pasted image 20250307162053.png]]
위 실행 결과를 보면 PID가 1번인 것을 알수 있습니다. 현재 실행환경이 도커 컨테이너이기 때문에 PID가 1번으로 나옵니다.


- 호스트 운영체제에서 도커 컨테이너로 실행하는 경우에 다음과 같이 PID를 조회할 수 있습니다.
```shell
docker inspect --format '{{.State.Pid}}' fineAnts_app
```
![[Pasted image 20250307161252.png]]
  
**jmap 명령어로 힙덤프 파일 생성하기**
다음은 힙 덤프 파일을 생성하기 위한 명령어 형식입니다.
```shell
jmap -dump:format=b,file=testdump.hprof ${pid}
```

예를 들어 위 예시에서 나온 fineAnts_app spring 서버의 힙 덤프 파일을 생성해봅니다. testdump.hprof는 생성될 힙 덤프 파일 이름입니다.
```shell
jmap -dump:format=b,file=testdump.hprof 1
```
![[Pasted image 20250307162311.png]]
실행 결과를 보면 약 190MB 정도의 testdump.hprof 파일이 생성된 것을 볼수 있습니다.

### 테스트를 위한 OOM 발생시키기
다음과 같은 자바 소스코드를 구현하여 OOM이 발생할 수 있도록 구현해봅니다.

우선은 다음과 같이 예제 클래스를 생성합니다.
Example1.java
```java
import java.util.ArrayList;
public class Example1{
	public static void main(String[] args) throws InterruptedException{
		Example1 example = new Example1();
		example.test();
	}
	public void test() throws InterruptedException {
		ArrayList<int[]> list = new ArrayList();
		try {
			for(int i=0; i < 250000; i++) {
		      list.add(new int[10_000_000]); // 리스트에 배열을 추가한다
		      System.out.println(i);
		     Thread.sleep(1);
		    }
		  } catch (Exception e) {
		    e.printStackTrace();
		  }
	}
}
```

위 자바 소스 코드 파일을 컴파일합니다.
```shell
javac Example1.java
```

MANIFEST.MF 파일을 작성합니다.
MANIFEST.MF
```text
Manifest-Version: 1.0
Main-Class: Example1
```

jar 파일로 패키징합니다.
```
jar cvmf MANIFEST.MF Example1.jar Example1.class
```
![[Pasted image 20250307163756.png]]
위 실행 결과와 같이 Example1.jar 파일을 생성합니다.

jar 파일을 실행시켜서 오류를 발생시키고 힙 덤프 파일을 생성해봅니다.
```shell
java -jar -Xms128M -Xmx128M \
-XX:+HeapDumpOnOutOfMemoryError \
-XX:HeapDumpPath=./ \
-XX:OnOutOfMemoryError="kill -9 %p" \
Example1.jar
```
![[Pasted image 20250307164111.png]]

위 실행 결과를 보면 java_pid11486.hprof 힙 덤프 파일이 생성된 것을 볼수 있습니다.

### 힙덤프 파일을 어떻게 분석하면 좋을까?
#### 이클립스 MAT(Eclipse Memory Analyzer Tool)
이클립스 MAT는 다음 링크를 통해서 다운로드받고 실행합니다.
- https://eclipse.dev/mat/download/

![[Pasted image 20250307164844.png]]


생성된 힙 덤프 파일을 이클립스 MAT을 이용해서 실행합니다.
![[Pasted image 20250307164919.png]]

다음 화면에서 Reports 메뉴에서 Leak Suspects 메뉴를 선택해봅니다.
![[Pasted image 20250307165027.png]]

보고서를 확인해보면 Example1 클래스의 test() 메서드에서 12번째 줄에서 에러가 발생하였고 Object[] 배열 타입의 인스턴스중에 하나가 메모리를 99.25% 점유하고 있는 것을 알려주고 있습니다.
![[Pasted image 20250307165122.png]]

위 화면에서 Details 버튼을 누르면 Dominator Tree를 확인할 수 있습니다.
![[Pasted image 20250307165601.png]]
실행 결과를 보면 int[] 타입의 배열 3개가 99.25%(120,000,048)을 메모리에서 차지하는 것을 볼수 있습니다.

다음 화면에서  "See stacktrace" 링크를 클릭하여 stacktrace를 통해서 에러가 발생하는 시작점을 확인할 수 있습니다.
![[Pasted image 20250307165819.png]]

실행 결과를 보면 Example1.java 파일에서 12번째 줄에서 에러가 발생한 것을 볼수 있습니다.
![[Pasted image 20250307165903.png]]

Example1.java 파일에서 12번째 줄의 코드는 다음과 같습니다. 실행 결과를 보면 리스트에 new int[10_000_000] 크기의 배열을 넣으려다가 OOM이 발생한 것을 볼수 있습니다.
![[Pasted image 20250307165943.png]]
